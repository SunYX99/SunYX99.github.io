<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Css学习笔记</title>
    <url>/2020/03/23/Css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Css学习笔记"><a href="#Css学习笔记" class="headerlink" title="Css学习笔记"></a><center>Css学习笔记</center></h1><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p> Cascading Style Sheets 层叠样式表</p>
<ul>
<li>多个样式可以作用在同一个html的元素上，同时生效</li>
</ul>
<h3 id="二、优点"><a href="#二、优点" class="headerlink" title="二、优点"></a>二、优点</h3><ol>
<li>功能强大。</li>
<li>将内容展示和样式控制分离。<ul>
<li>降低耦合度。解耦</li>
<li>让分工协作更容易</li>
<li>提高开发效率</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h3 id="三、Css的使用"><a href="#三、Css的使用" class="headerlink" title="三、Css的使用"></a>三、Css的使用</h3><p>1.<strong>内联样式</strong>      </p>
<ul>
<li>在标签内使用style属性指定css代码</li>
<li>如：<code>&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code></li>
</ul>
<p>2.<strong>内部样式</strong></p>
<ul>
<li><p>在标签内使用style属性指定css代码</p>
</li>
<li><p>如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      	div&#123;</span><br><span class="line"><span class="css">      	 <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">      	&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>3.<strong>外部样式</strong></p>
<p>1.定义css资源文件。</p>
<p>2.在head标签内，定义link标签，引入外部的资源文件</p>
<ul>
<li><p>如：a.css文件：div{color:green;}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;a.css&quot;&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><code>3种格式可以写为：&lt;style&gt; @import &quot;css/a.css；&lt;/style&gt;</code></p>
<p>4.<strong>Css语法</strong></p>
<ul>
<li><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">	属性名1:属性值1;</span><br><span class="line">	属性名2:属性值2;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择器:筛选具有相似特征的元素。</p>
</li>
<li><p><strong>注意</strong>：每一对属性需要使用；隔开，最后一对属性可以不加；</p>
</li>
</ul>
<p>5.<strong>选择器</strong></p>
<ul>
<li>分类：<ol>
<li>基础选择器<ul>
<li>id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一。</li>
<li>语法：#id属性值{}</li>
</ul>
</li>
<li>元素选择器：选择具有相同标签名称的元素<ul>
<li>语法： 标签名称{}</li>
<li><strong>注意</strong>：id选择器优先级高于元素选择器**。</li>
</ul>
</li>
<li>类选择器：选择具有相同的class属性值的元素。<ul>
<li>语法：.class属性值{}</li>
<li><strong>注意</strong>：类选择器选择器优先级高于元素选择器。**</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>扩展选择器</strong>：</p>
<ol>
<li><p>选择所有元素：</p>
<ul>
<li>语法： *{}</li>
</ul>
</li>
<li><p>并集选择器：</p>
<ul>
<li>选择器1,选择器2{}</li>
</ul>
</li>
<li><p>子选择器：筛选选择器1元素下的选择器2元素</p>
<ul>
<li>语法：  选择器1 选择器2{}</li>
</ul>
</li>
<li><p>父选择器：筛选选择器2的父元素选择器1</p>
<ul>
<li>语法：  选择器1 &gt; 选择器2{}</li>
</ul>
</li>
<li><p>属性选择器：选择元素名称，属性名=属性值的元素</p>
<ul>
<li>语法：  元素名称[属性名=”属性值”]{}</li>
</ul>
</li>
<li><p>伪类选择器：选择一些元素具有的状态</p>
<ul>
<li><p>语法： 元素:状态{}</p>
</li>
<li><p>如：<code>&lt;a&gt;</code></p>
<ul>
<li><p>状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link：初始化的状态</span><br><span class="line">visited：被访问过的状态</span><br><span class="line">active：正在访问状态</span><br><span class="line">hover：鼠标悬浮状态</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>6.<strong>CSS常用属性</strong></p>
<p>1.字体、文本</p>
<ul>
<li>font-size:字体大小</li>
<li>color：文本颜色</li>
<li>text-align：对其方式</li>
<li>line-height：行高 </li>
</ul>
<p>2.背景</p>
<ul>
<li><p>background：</p>
</li>
<li><p>语法：background: <em>color position size repeat origin clip attachment  image</em>;</p>
</li>
<li><p>例如：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background: #00ff00 url('smiley.gif') no-repeat fixed center</span><br></pre></td></tr></table></figure>





</li>
</ul>
<p>3.边框</p>
<ul>
<li><p>border:border-width, border-style,border-color</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">border:1px solider red</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4.尺寸</p>
<ul>
<li>width：宽度</li>
<li>height：高度</li>
</ul>
<p>5.盒子模型</p>
<ul>
<li>margin：外边距</li>
<li>padding：内边距<ul>
<li>默认情况下内边距会影响整个盒子的大小</li>
<li>box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小</li>
</ul>
</li>
<li>float：浮动<ul>
<li>left: 左浮动</li>
<li>right:右浮动</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2020/03/24/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>​    在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p>
<p>​    在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件   对资源充分利用</p>
<p>​    虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p>
<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>​    Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。</p>
<p>​    <img src="/" class="lazyload" data-src="/img/docker/1-3.png"  alt=""></p>
<p>​    Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p>
<p>​    Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p>
<p>​    在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>
<p>为什么选择Docker?</p>
<p>（1）上手快。</p>
<p>​    用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”(copy-on-write)模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。<br>​    随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p>
<p>（2）职责的逻辑分类</p>
<p>​    使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p>
<p>（3）快速高效的开发生命周期</p>
<p>​    Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p>
<p>（4）鼓励使用面向服务的架构</p>
<p>​    Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p>
<h2 id="容器与虚拟机比较"><a href="#容器与虚拟机比较" class="headerlink" title="容器与虚拟机比较"></a>容器与虚拟机比较</h2><p>​    下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/" class="lazyload" data-src="/img/docker/1-1.png"  alt=""></p>
<p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p>
<h2 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a>Docker 组件</h2><h3 id="Docker服务器与客户端"><a href="#Docker服务器与客户端" class="headerlink" title="Docker服务器与客户端"></a>Docker服务器与客户端</h3><p>​    Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p>
<p><img src="/" class="lazyload" data-src="/img/docker/1-2.png"  alt=""></p>
<h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><p>​    镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p>
<p>添加一个文件；</p>
<p>执行一个命令；</p>
<p>打开一个窗口。</p>
<p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p>
<p>​    Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。  容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p>
<p>所以Docker容器就是：</p>
<p>​    一个镜像格式；</p>
<p>​    一些列标准操作；</p>
<p>​    一个执行环境。</p>
<p>​    Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。<br>​    和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。<br>​    Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</p>
<h3 id="Registry（注册中心）"><a href="#Registry（注册中心）" class="headerlink" title="Registry（注册中心）"></a>Registry（注册中心）</h3><p>​    Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p>
<p>​    <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>​    Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p>
<p>​    由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p>
<p>​    请直接挂载课程配套的Centos7.x镜像    </p>
<p>(1)yum 包更新到最新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>（3）设置yum源为阿里云</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>（4）安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>

<p>（5）安装后查看docker版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<h2 id="设置ustc的镜像"><a href="#设置ustc的镜像" class="headerlink" title="设置ustc的镜像"></a>设置ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p>
<p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p>
<p>编辑该文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>

<p>在该文件中输入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Docker的启动与停止"><a href="#Docker的启动与停止" class="headerlink" title="Docker的启动与停止"></a>Docker的启动与停止</h2><p><strong>systemctl</strong>命令是系统服务管理器指令</p>
<p>启动docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>停止docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>重启docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>查看docker状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>开机启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>查看docker概要信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>查看docker帮助文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>REPOSITORY：镜像名称</p>
<p>TAG：镜像标签</p>
<p>IMAGE ID：镜像ID</p>
<p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p>
<p>SIZE：镜像大小</p>
<p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p>
<h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure>

<p>NAME：仓库名称</p>
<p>DESCRIPTION：镜像描述</p>
<p>STARS：用户评价，反应一个镜像的受欢迎程度</p>
<p>OFFICIAL：是否官方</p>
<p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>拉取镜像就是从中央仓库中下载镜像到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure>

<p>例如，我要下载centos7镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>按镜像ID删除镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure>

<p>删除所有镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi &#96;docker images -q&#96;</span><br></pre></td></tr></table></figure>

<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>查看所有容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure>

<p>查看最后一次运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure>

<p>查看停止的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -f status&#x3D;exited</span><br></pre></td></tr></table></figure>

<h3 id="创建与启动容器"><a href="#创建与启动容器" class="headerlink" title="创建与启动容器"></a>创建与启动容器</h3><p>创建容器常用的参数说明：</p>
<p>创建容器命令：docker run</p>
<p> -i：表示运行容器</p>
<p> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p>
<p> –name :为创建的容器命名。</p>
<p> -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p>
<p> -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p>
<p> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p>
<p>（1）交互式方式创建容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态  </p>
<p>退出当前容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>（2）守护式方式创建容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure>

<p>登录守护式容器方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 (或者容器ID)  &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><p>停止容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>

<p>启动容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>

<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure>

<p>也可以将文件从容器内拷贝出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure>

<h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml --name&#x3D;mycentos3 centos:7</span><br></pre></td></tr></table></figure>

<p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p>
<p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  –privileged=true  来解决挂载的目录没有权限的问题</p>
<h3 id="查看容器IP地址"><a href="#查看容器IP地址" class="headerlink" title="查看容器IP地址"></a>查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<p>也可以直接执行下面的命令直接输出IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除指定的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<h1 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><p>（1）拉取mysql镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos&#x2F;mysql-57-centos7</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql</span><br></pre></td></tr></table></figure>

<p>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</p>
<p>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p>
<p>（3）远程登录mysql</p>
<p>连接宿主机的IP  ,指定端口为33306 </p>
<h2 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a>tomcat部署</h2><p>（1）拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<p>创建容器  -p表示地址映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mytomcat -p 9000:8080 </span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure>

<h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><p>（1）拉取镜像    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>（2）创建Nginx容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>

<h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><p>（1）拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>

<h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h1><h2 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure>

<h2 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h2><p>我们可以通过以下命令将镜像保存为tar 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure>

<h2 id="镜像恢复与迁移"><a href="#镜像恢复与迁移" class="headerlink" title="镜像恢复与迁移"></a>镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure>

<p>-i 输入的文件</p>
<p>执行后再次查看镜像，可以看到镜像已经恢复</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p>
<p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p>
<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td>定义了使用哪个基础镜像启动构建流程</td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的创建者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量 (可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>是Dockerfile的核心部分(可以写多条)</td>
</tr>
<tr>
<td>ADD source_dir/file dest_dir/file</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir/file dest_dir/file</td>
<td>和ADD相似，但是如果有压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
</tbody></table>
<h2 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a>使用脚本创建镜像</h2><p>步骤：</p>
<p>（1）创建目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8</span><br></pre></td></tr></table></figure>

<p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p>
<p>（3）创建文件Dockerfile  <code>vi Dockerfile</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#依赖镜像名称和ID</span><br><span class="line">FROM centos:7</span><br><span class="line">#指定镜像创建者信息</span><br><span class="line">MAINTAINER ITCAST</span><br><span class="line">#切换工作目录</span><br><span class="line">WORKDIR &#x2F;usr</span><br><span class="line">RUN mkdir  &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line">#ADD 是相对路径jar,把java添加到容器中</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br><span class="line"></span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME&#x2F;jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p>（4）执行命令构建镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t&#x3D;&#39;jdk1.8&#39; .</span><br></pre></td></tr></table></figure>

<p>注意后边的空格和点，不要省略</p>
<p>（5）查看镜像是否建立完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>



<h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><h2 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h2><p>（1）拉取私有仓库镜像（此步省略）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>

<p>（2）启动私有仓库容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure>

<p>（3）打开浏览器 输入地址http://你的IP地址:5000/v2/_catalog看到<code>{&quot;repositories&quot;:[]}</code> 表示私有仓库搭建成功并且内容为空</p>
<p>（4）修改daemon.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>

<p>添加以下内容，保存退出。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"insecure-registries"</span>:[<span class="string">"你的IP地址:5000"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>此步用于让 docker信任私有仓库地址</p>
<p>（5）重启docker 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag jdk1.8 你的IP地址:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure>

<p>（2）再次启动私服容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure>

<p>（3）上传标记的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push 你的IP地址:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/03/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a><center>Linux常用命令</center></h1><h2 id="切换目录命令cd"><a href="#切换目录命令cd" class="headerlink" title="切换目录命令cd"></a>切换目录命令cd</h2><p>使用cd app   切换到app目录 </p>
<p>cd ..  切换到上一层目录<br>cd /     切换到系统根目录<br>cd ~   切换到用户主目录<br>cd -     切换到上一个所在目录</p>
<p>使用tab键来补全文件路径</p>
<h2 id="列出文件列表：ls-ll"><a href="#列出文件列表：ls-ll" class="headerlink" title="列出文件列表：ls ll"></a>列出文件列表：ls ll</h2><p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。</p>
<p>格式：ls[参数] [路径或文件名]</p>
<p>在linux中以 . 开头的文件都是隐藏的文件</p>
<p>ls<br>ls -a 显示所有文件或目录（包含隐藏的文件）<br>ls -l 缩写成ll</p>
<h2 id="创建目录和移除目录：mkdir-rmdir"><a href="#创建目录和移除目录：mkdir-rmdir" class="headerlink" title="创建目录和移除目录：mkdir rmdir"></a>创建目录和移除目录：mkdir rmdir</h2><p>mkdir(make directory)命令可用来创建子目录。<br>mkdir app     在当前目录下创建app目录<br>mkdir –p app2/test  级联创建aap2以及test目<br>rmdir(remove directory)命令可用来删除“空”的子目录:rmdir app  删除app目录</p>
<h2 id="浏览文件"><a href="#浏览文件" class="headerlink" title="浏览文件"></a>浏览文件</h2><p><strong>【cat、more、less】</strong></p>
<p>cat用于显示文件的内容。格式：cat[参数]&lt;文件名&gt;</p>
<blockquote>
<p> cat a.txt</p>
</blockquote>
<p>more一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。</p>
<p>回车显示下一行内容。按 q 键退出查看。</p>
<blockquote>
<p>more yum.conf</p>
<p>空格显示下一页数据 回车显示下一行的数据</p>
</blockquote>
<p>less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制.</p>
<blockquote>
<p>less yum.conf</p>
<p>PgUp 和 PgDn 进行上下翻页.</p>
</blockquote>
<p><strong>tail</strong></p>
<p>tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。</p>
<p>用法:</p>
<blockquote>
<p>tail -10 /etc/passwd    查看后10行数据</p>
<p>tail -f catalina.log   动态查看日志</p>
<p>ctrl+c 结束查看</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><strong>【rm】</strong></p>
<p>rm 删除文件</p>
<ul>
<li><p>用法：</p>
<blockquote>
<p>rm [选项]… 文件..<br>rm a.txt  删除a.txt文件   删除需要用户确认，y/n<br>rm -f a.txt  不询问，直接删除rm 删除目录<br>rm -r a    递归删除不询问递归删除（慎用）<br>rm -rf a  不询问递归删除<br>rm -rf *    删除所有文件<br>rm -rf /*    删除系统所有文件，危险行为</p>
</blockquote>
</li>
</ul>
<p><strong>【cp、mv】</strong></p>
<p>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<blockquote>
<p>cp a.txt b.txt  将a.txt复制为b.txt文件<br>cp a.txt ../    将a.txt文件复制到上一层目录中</p>
</blockquote>
<p>mv 移动或者重命名：</p>
<blockquote>
<p>mv a.txt ../  将a.txt文件移动到上一层目录中<br>mv a.txt b.txt  将a.txt文件重命名为b.txt</p>
</blockquote>
<p><strong>【tar】命令:( 打包或解压)</strong></p>
<p>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。</p>
<p>常用参数：</p>
<blockquote>
<p>-c：创建一个新tar文件<br>-v：显示运行过程的信息<br>-f：指定文件名<br>-z：调用gzip压缩命令进行压缩<br>-t：查看压缩文件的内容<br>-x：解开tar文件</p>
</blockquote>
<p>打包：</p>
<blockquote>
<p>tar –cvf  xxx.tar  ./*</p>
</blockquote>
<p>打包并且压缩：</p>
<blockquote>
<p> tar –zcvf xxx.tar.gz ./*</p>
</blockquote>
<p>解压 ：tar –xvf xxx.tar</p>
<blockquote>
<p>tar -zxvf xxx.tar.gz -C /usr/aaa</p>
</blockquote>
<p><strong>【find】命令</strong></p>
<p>find指令用于查找符合条件的文件。</p>
<p>示例：</p>
<blockquote>
<p> find / -name “ins*” 查找文件名称是以ins开头的文件</p>
<p>find / -name “ins*” –ls </p>
<p>find / –user ss –ls 查找用户ss的文件</p>
<p>find / –user ss–type d –ls 查找用户ss的目录</p>
<p>find /-perm -777 –type d-ls 查找权限是777的文件</p>
</blockquote>
<p><strong>【grep】命令</strong></p>
<p>查找文件里符合条件的字符串。</p>
<p>用法：</p>
<p>grep [选项]… PATTERN [FILE]…示例：</p>
<p>grep lang anaconda-ks.cfg     在文件中查找lang</p>
<p>grep lang anaconda-ks.cfg –color     高亮显示</p>
<blockquote>
<p>grep debug yum.conf –color</p>
<p>grep debug yum.conf –color  -A5</p>
<p>grep debug yum.conf –color -A5 -B5</p>
</blockquote>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p><strong>【pwd】</strong></p>
<p>显示当前所在目录</p>
<p><strong>【touch】</strong></p>
<p>创建一个空文件</p>
<blockquote>
<p>touch a.txt</p>
</blockquote>
<p><strong>【clear/ crtl + L】</strong></p>
<p>清屏</p>
<h2 id="VI和Vim编辑器"><a href="#VI和Vim编辑器" class="headerlink" title="VI和Vim编辑器"></a>VI和Vim编辑器</h2><p>在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。</p>
<p>切换到命令行模式：按Esc键</p>
<p>切换到插入模式：按 i 、o、a键；</p>
<blockquote>
<p>  i 在当前位置前插入</p>
<p>  I 在当前行首插入</p>
<p>  a 在当前位置后插入</p>
<p>  A 在当前行尾插入</p>
<p>  o 在当前行之后插入一行</p>
<p>  O 在当前行之前插入一行</p>
</blockquote>
<p>打开文件：vim file</p>
<p>退出：esc   :q</p>
<p>修改文件：输入i进入插入模式</p>
<p>保存并退出：esc :wq</p>
<p>不保存退出：esc :q!</p>
<p>三种进入插入模式：</p>
<blockquote>
<p> i:在当前的光标所在处插入<br>o:在当前光标所在的行的下一行插入<br>a:在光标所在的下一个字符插入</p>
</blockquote>
<p>快捷键：</p>
<blockquote>
<p>dd – 快速删除一行</p>
<p>yy - 复制当前行</p>
<p>nyy - 从当前行向后复制几行</p>
<p>p - 粘贴</p>
<p>R – 替换</p>
</blockquote>
<h2 id="重定向输出-gt-和-gt-gt"><a href="#重定向输出-gt-和-gt-gt" class="headerlink" title="重定向输出&gt;和&gt;&gt;"></a>重定向输出&gt;和&gt;&gt;</h2><p> 重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，又追加功能；示例：</p>
<blockquote>
<p>cat /etc/passwd &gt; a.txt 将输出定向到a.txt中</p>
<p>cat /etc/passwd &gt;&gt; a.txt 输出并且追加</p>
<p>ifconfig &gt; ifconfig.txt</p>
</blockquote>
<h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><p>ps 正在运行的某个进程的状态</p>
<blockquote>
<p>ps –ef 查看所有进程</p>
<p>ps –ef | grep ssh 查找某一进程</p>
<p>kill 2868 杀掉2868编号的进程</p>
<p>kill -9 2868 强制杀死进程</p>
</blockquote>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例：</p>
<blockquote>
<p>ls –help | more 分页查询帮助信息</p>
<p>ps –ef | grep java 查询名称中包含java的进程</p>
<p>ifconfig | more</p>
<p>cat index.html | more</p>
<p>ps –ef | grep aio</p>
</blockquote>
<h2 id="LInux权限命令"><a href="#LInux权限命令" class="headerlink" title="LInux权限命令"></a>LInux权限命令</h2><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p><img src="/" class="lazyload" data-src="/img/Linux/1.png"  alt=""></p>
<p><img src="/" class="lazyload" data-src="/img/Linux/2.png"  alt=""></p>
<p>r:对文件是指可读取内容 对目录是可以ls</p>
<p>w:对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</p>
<p>x:对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</p>
<h3 id="Linux三种文件类型："><a href="#Linux三种文件类型：" class="headerlink" title="Linux三种文件类型："></a>Linux三种文件类型：</h3><blockquote>
<p>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </p>
<p>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 </p>
<p>设备文件： Linux系统把每一个设备都看成是一个文件</p>
</blockquote>
<h3 id="文件类型标识"><a href="#文件类型标识" class="headerlink" title="文件类型标识"></a>文件类型标识</h3><blockquote>
<p>普通文件（-）目录（d）符号链接（l）</p>
<p>进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p</p>
</blockquote>
<h3 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h3><blockquote>
<p>chmod 变更文件或目录的权限。</p>
<p>chmod 755 a.txt </p>
<p>chmod u=rwx,g=rx,o=rx a.txt</p>
</blockquote>
<h2 id="Linux上常用网络操作"><a href="#Linux上常用网络操作" class="headerlink" title="Linux上常用网络操作"></a>Linux上常用网络操作</h2><h3 id="主机名配置"><a href="#主机名配置" class="headerlink" title="主机名配置"></a>主机名配置</h3><blockquote>
<p>hostname 查看主机名</p>
<p>hostname xxx 修改主机名 重启后无效</p>
<p>如果想要永久生效，可以修改/etc/sysconfig/network文件</p>
</blockquote>
<h3 id="IP地址配置"><a href="#IP地址配置" class="headerlink" title="IP地址配置"></a>IP地址配置</h3><blockquote>
<p>ifconfig 查看(修改)ip地址(重启后无效)</p>
<p>ifconfig eth0 192.168.12.22 修改ip地址</p>
<p>如果想要永久生效</p>
<p>修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件</p>
<p>DEVICE=eth0 #网卡名称</p>
<p>BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none)</p>
<p>HWADDR=00:0C:29:B5:B2:69 #MAC地址</p>
<p>IPADDR=12.168.177.129 #IP地址<br>NETMASK=255.255.255.0 #子网掩码<br>NETWORK=192.168.177.0 #网络地址<br>BROADCAST=192.168.0.255 #广播地址</p>
<p>NBOOT=yes #  系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。</p>
</blockquote>
<h3 id="域名映射"><a href="#域名映射" class="headerlink" title="域名映射"></a>域名映射</h3><p>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:\Windows\System32\drivers\etc\hosts文件的功能</p>
<h3 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h3><blockquote>
<p>service network status 查看指定服务的状态</p>
<p>service network stop 停止指定服务</p>
<p>service network start 启动指定服务</p>
<p>service network restart 重启指定服务</p>
<p>service –status–all 查看系统中所有后台服务</p>
<p>netstat –nltp 查看系统中网络进程的端口监听情况</p>
<p>防火墙设置</p>
<p>防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。</p>
<p>service iptables status 查看防火墙状态</p>
<p>service iptables stop 关闭防火墙</p>
<p>service iptables start 启动防火墙</p>
<p>chkconfig iptables off 禁止防火墙自启</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2020/03/21/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a><center>MarkDown语法<center></h2><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比WYSIWYG编辑器</p>
<p><strong>优点：</strong></p>
<p>1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br> 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p>
<p><strong>缺点：</strong></p>
<p>1、需要记一些语法（当然，是很简单。五分钟学会）。</p>
<p>2、有些平台不支持Markdown编辑模式。</p>
<a id="more"></a>

<p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一级标题</span></span><br><span class="line"><span class="comment">## 这是二级标题</span></span><br><span class="line"><span class="comment">### 这是三级标题</span></span><br><span class="line"><span class="comment">#### 这是四级标题</span></span><br><span class="line"><span class="comment">##### 这是五级标题</span></span><br><span class="line"><span class="comment">###### 这是六级标题</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><ul>
<li><strong>加粗</strong></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><p><em>斜体</em></p>
</li>
<li><p>要倾斜的文字左右分别用一个*号包起来</p>
</li>
</ul>
<p><strong><em>斜体加粗</em></strong></p>
<ul>
<li>要倾斜和加粗的文字左右分别用三个*号包起来</li>
</ul>
<p><del>删除线</del></p>
<ul>
<li>要加删除线的文字左右分别用两个~~号包起来</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>
<h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…</p>
<p>貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure>

<p>效果如下：<br>可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 <span class="string">''</span>图片title<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/" class="lazyload" data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fitea-cdn.qq.com%2Ffile%2Feditor%2F2020062514%2F1593066924.245939824bac27b16acf77b3480260ff.png&refer=http%3A%2F%2Fitea-cdn.qq.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621910832&t=f480b25e767f59ecea48884f3a1506ca"  alt="图片" title="王者荣耀"></p>
<p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p>
<p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。</p>
<h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 <span class="string">"超链接title"</span>)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"超链接地址"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>超链接名<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.jianshu.com/u/1f5ac0cf6a8b"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>简书<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>语法：</p>
<p>序列表用 - + * 任何一种都可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法：<br>数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li><p>一级无序列表内容</p>
<ul>
<li>二级无序列表内容</li>
</ul>
<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li><p>一级无序列表内容</p>
<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容 </li>
</ol>
</li>
</ul>
<ol>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`代码内容`</span></span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(<span class="string">``</span><span class="string">`)</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">(`</span><span class="string">``</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`create database ddd;`</span></span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<p><code>create database ddd</code>;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">​```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;``</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>网页有可能不支持流程图，所以我把图片截取下来了</p>
<p><img src="/" class="lazyload" data-src="/img/liucheng.jpg"  alt="流程图" title="流程图"></p>
<p>以上就i是MarkDown的基本语法，这些应该足够我们用了， MarkDown用起来也很方便！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>MarkDown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（三）</title>
    <url>/2020/03/28/Mybatie%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（三）"><a href="#Mybatis学习笔记（三）" class="headerlink" title="Mybatis学习笔记（三）"></a><center>Mybatis学习笔记（三）</center></h1><h2 id="Mybatis-的输出结果封装"><a href="#Mybatis-的输出结果封装" class="headerlink" title="Mybatis 的输出结果封装"></a>Mybatis 的输出结果封装</h2><h3 id="resultMap-结果类型"><a href="#resultMap-结果类型" class="headerlink" title="resultMap 结果类型"></a>resultMap 结果类型</h3><blockquote>
<p>resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。<br>在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类<br>型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。  </p>
</blockquote>
<h3 id="定义-resultMap"><a href="#定义-resultMap" class="headerlink" title="定义 resultMap"></a>定义 resultMap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 建立 User 实体和数据库表的对应关系type </span><br><span class="line">属性：指定实体类的全限定类名</span><br><span class="line">id 属性：给定一个唯一标识，是给查询 select 标签引用用的。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;resultMap type&#x3D;&quot;com.itheima.domain.User&quot; id&#x3D;&quot;userMap&quot;&gt;</span><br><span class="line">&lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;userId&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;userName&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;userSex&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;address&quot; property&#x3D;&quot;userAddress&quot;&#x2F;&gt;</span><br><span class="line">&lt;result column&#x3D;&quot;birthday&quot; property&#x3D;&quot;userBirthday&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>id 标签：用于指定主键字段<br>result 标签：用于指定非主键字段<br>column 属性：用于指定数据库列名<br>property 属性：用于指定实体类属性名称  </p>
</blockquote>
<h3 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置查询所有操作 --&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;userMap&quot;&gt;</span><br><span class="line">select * from user</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="SqlMapConfig-xml配置文件"><a href="#SqlMapConfig-xml配置文件" class="headerlink" title="SqlMapConfig.xml配置文件"></a>SqlMapConfig.xml配置文件</h2><h3 id="SqlMapConfig-xml-中配置的内容和顺序"><a href="#SqlMapConfig-xml-中配置的内容和顺序" class="headerlink" title="SqlMapConfig.xml 中配置的内容和顺序"></a>SqlMapConfig.xml 中配置的内容和顺序</h3><blockquote>
<p>-properties（属性）<br>—property<br>-settings（全局配置参数）<br>—setting<br>-typeAliases（类型别名）<br>—typeAliase<br>—package<br>-typeHandlers（类型处理器）<br>-objectFactory（对象工厂）<br>-plugins（插件）<br>-environments（环境集合属性对象）<br>—environment（环境子属性对象）<br>  —–transactionManager（事务管理）<br>  —–dataSource（数据源）<br>-mappers（映射器）<br>—mapper<br>    —package  </p>
</blockquote>
<h3 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h3><blockquote>
<p>在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。  </p>
</blockquote>
<h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbc.password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><ul>
<li><p>*<em>在 classpath 下定义 db.properties 文件  *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;root</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>properties 标签配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置连接数据库的信息</span><br><span class="line">resource 属性：用于指定 properties 配置文件的位置，要求配置文件必须在类路径下</span><br><span class="line">resource&#x3D;&quot;jdbcConfig.properties&quot;</span><br><span class="line">url 属性：</span><br><span class="line">URL： Uniform Resource Locator 统一资源定位符</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;mystroe&#x2F;CategoryServlet URL</span><br><span class="line">协议 主机 端口 URI</span><br><span class="line">URI： Uniform Resource Identifier 统一资源标识符</span><br><span class="line">&#x2F;mystroe&#x2F;CategoryServlet</span><br><span class="line">它是可以在 web 应用中唯一定位一个资源的路径</span><br><span class="line">--&gt;</span><br><span class="line">&lt;properties url&#x3D;</span><br><span class="line">file:&#x2F;&#x2F;&#x2F;D:&#x2F;IdeaProjects&#x2F;day02_eesy_01mybatisCRUD&#x2F;src&#x2F;main&#x2F;resources&#x2F;jdbcConfig.prop</span><br><span class="line">erties&quot;&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>*<em>此时我们的 dataSource 标签就变成了引用上面的配置  *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dataSource&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="typeAliases（类型别名）"><a href="#typeAliases（类型别名）" class="headerlink" title="typeAliases（类型别名）"></a>typeAliases（类型别名）</h3><blockquote>
<p>在前面我们讲的 Mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发。  </p>
</blockquote>
<h4 id="自定义别名："><a href="#自定义别名：" class="headerlink" title="自定义别名："></a>自定义别名：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 SqlMapConfig.xml 中配置：</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;!-- 单个别名定义 --&gt;</span><br><span class="line">&lt;typeAlias alias&#x3D;&quot;user&quot; type&#x3D;&quot;com.itheima.domain.User&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt;</span><br><span class="line">&lt;package name&#x3D;&quot;com.itheima.domain&quot;&#x2F;&gt;</span><br><span class="line">&lt;package name&#x3D;&quot;其它包&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure>

<h3 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h3><p><code>1.&lt;mapper resource=&quot; &quot; /&gt;</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用相对于类路径的资源</span><br><span class="line">如： &lt;mapper resource&#x3D;&quot;com&#x2F;itheima&#x2F;dao&#x2F;IUserDao.xml&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><code>2.&lt;mapper class=&quot; &quot; /&gt;</code>  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 mapper 接口类路径</span><br><span class="line">如： &lt;mapper class&#x3D;&quot;com.itheima.dao.UserDao&quot;&#x2F;&gt;</span><br><span class="line">注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</span><br></pre></td></tr></table></figure>

<p><code>3.&lt;package name=&quot;&quot;/&gt;</code>  </p>
<figure class="highlight plain"><figcaption><span>mapper 接口</span></figcaption><table><tr><td class="code"><pre><span class="line">如： &lt;package name&#x3D;&quot;cn.itcast.mybatis.mapper&quot;&#x2F;&gt;</span><br><span class="line">注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（二）</title>
    <url>/2020/03/28/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（二）"><a href="#Mybatis学习笔记（二）" class="headerlink" title="Mybatis学习笔记（二）"></a><center>Mybatis学习笔记（二）</center></h1><h2 id="根据ID查询"><a href="#根据ID查询" class="headerlink" title="根据ID查询"></a>根据ID查询</h2><h3 id="在持久层接口中添加-findById-方法"><a href="#在持久层接口中添加-findById-方法" class="headerlink" title="在持久层接口中添加 findById 方法"></a>在持久层接口中添加 findById 方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据Id查询</span><br><span class="line"> *&#x2F;</span><br><span class="line">User findById(int userId);</span><br></pre></td></tr></table></figure>

<h3 id="在用户的映射配置文件中配置"><a href="#在用户的映射配置文件中配置" class="headerlink" title="在用户的映射配置文件中配置"></a>在用户的映射配置文件中配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据Id查询--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;com.syx.domain.User&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">    select * from user  where id &#x3D; #&#123;uid&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>细节：<br><strong>resultType 属性</strong>：用于指定结果集的类型。<br><strong>parameterType 属性</strong>：  用于指定传入参数的类型。<br><strong>sql 语句中使用#{}字符</strong>：它代表占位符， 相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。<br> <strong>#{}中内容的写法</strong>：由于数据类型是基本类型，所以此处可以随意写。  </p>
<h3 id="在测试类添加测试"><a href="#在测试类添加测试" class="headerlink" title="在测试类添加测试"></a>在测试类添加测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    private InputStream in ;</span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">       in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建构建者对象</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        &#x2F;&#x2F; 3.创建SqlSession工厂对象</span><br><span class="line">         factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;4.创建SqlSession对向</span><br><span class="line">        session &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;5.创建Dao代理对象</span><br><span class="line">        userDao &#x3D; session.getMapper(IUserDao.class);</span><br><span class="line">        &#125;</span><br><span class="line">        @After</span><br><span class="line">        public void destroy() throws Exception&#123;</span><br><span class="line">            session.commit();</span><br><span class="line">            &#x2F;&#x2F;7.释放资源</span><br><span class="line">            session.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void findById()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;6.执行操作</span><br><span class="line">        User user &#x3D; userDao.findById(41);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保存操作"><a href="#保存操作" class="headerlink" title="保存操作"></a>保存操作</h2><h3 id="在持久层接口中新增方法"><a href="#在持久层接口中新增方法" class="headerlink" title="在持久层接口中新增方法"></a>在持久层接口中新增方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *保存用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">int saveUser(User user);</span><br></pre></td></tr></table></figure>

<h3 id="在用户的映射配置文件中配置-1"><a href="#在用户的映射配置文件中配置-1" class="headerlink" title="在用户的映射配置文件中配置"></a>在用户的映射配置文件中配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 保存用户--&gt;</span><br><span class="line">&lt;insert id&#x3D;&quot;saveUser&quot; parameterType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">    insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<p>细节：<br>parameterType 属性：代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。<br>sql 语句中使用#{}字符：它代表占位符， 相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。<br>#{}中内容的写法：由于我们保存方法的参数是 一个 User 对象，此处要写 User 对象中的属性名称。它用的是 ognl 表达式。<br>ognl 表达式：<br>它是 apache 提供的一种表达式语言， 全称是Object Graphic Navigation Language 对象图导航语言它是按照一定的语法格式来获取数据的。语法格式就是使用 #{对象.对象}的方式</p>
<p>#{user.username}它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用getUsername()方法把值取出来。但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user.而直接写 username。  </p>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void saveUser()&#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUsername(&quot;Mybatis save&quot;);</span><br><span class="line">        user.setSex(&quot;男&quot;);</span><br><span class="line">        user.setAddress(&quot;河南&quot;);</span><br><span class="line">        user.setBirthday(new Date());</span><br><span class="line">        int i &#x3D; userDao.saveUser(user);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题扩展：新增用户-id-的返回值"><a href="#问题扩展：新增用户-id-的返回值" class="headerlink" title="问题扩展：新增用户 id 的返回值"></a>问题扩展：新增用户 id 的返回值</h3><p>新增用户后， 同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 保存用户--&gt;</span><br><span class="line">&lt;insert id&#x3D;&quot;saveUser&quot; parameterType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">    &lt;!-- 配置保存时获取插入的 id --&gt;</span><br><span class="line">    &lt;selectKey keyColumn&#x3D;&quot;id&quot; keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">        select last_insert_id();</span><br><span class="line">    &lt;&#x2F;selectKey&gt;</span><br><span class="line">    insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<h2 id="用户更新"><a href="#用户更新" class="headerlink" title="用户更新"></a>用户更新</h2><h3 id="在持久层接口中添加更新方法"><a href="#在持久层接口中添加更新方法" class="headerlink" title="在持久层接口中添加更新方法"></a>在持久层接口中添加更新方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 更新用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">int updateUser(User user);</span><br></pre></td></tr></table></figure>

<h3 id="在用户的映射配置文件中配置-2"><a href="#在用户的映射配置文件中配置-2" class="headerlink" title="在用户的映射配置文件中配置"></a>在用户的映射配置文件中配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 更新用户--&gt;</span><br><span class="line">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">    update user set username&#x3D;#&#123;username&#125;,birthday&#x3D;#&#123;birthday&#125;,sex&#x3D;#&#123;sex&#125;,address&#x3D;#&#123;address&#125; where id&#x3D;#&#123;id&#125;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加入更新的测试方法"><a href="#加入更新的测试方法" class="headerlink" title="加入更新的测试方法"></a>加入更新的测试方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void updateUser()&#123;</span><br><span class="line">      User user &#x3D; new User();</span><br><span class="line">      user.setId(51);</span><br><span class="line">      user.setUsername(&quot;Mybatis update&quot;);</span><br><span class="line">      user.setSex(&quot;男&quot;);</span><br><span class="line">      user.setAddress(&quot;河南&quot;);</span><br><span class="line">      user.setBirthday(new Date());</span><br><span class="line">      userDao.updateUser(user);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h2><h3 id="在持久层接口中添加删除方法"><a href="#在持久层接口中添加删除方法" class="headerlink" title="在持久层接口中添加删除方法"></a>在持久层接口中添加删除方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">int deleteUser(Integer userId);</span><br></pre></td></tr></table></figure>

<h3 id="在用户的映射配置文件中配置-3"><a href="#在用户的映射配置文件中配置-3" class="headerlink" title="在用户的映射配置文件中配置"></a>在用户的映射配置文件中配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 删除用户--&gt;</span><br><span class="line">&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;Integer&quot;&gt;</span><br><span class="line">    delete from user where id &#x3D; #&#123;uid&#125;</span><br><span class="line">&lt;&#x2F;delete&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加入删除的测试方法"><a href="#加入删除的测试方法" class="headerlink" title="加入删除的测试方法"></a>加入删除的测试方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void deleteUser()&#123;</span><br><span class="line">    userDao.deleteUser(51);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户模糊查询"><a href="#用户模糊查询" class="headerlink" title="用户模糊查询"></a>用户模糊查询</h2><h3 id="在持久层接口中添加模糊查询方法"><a href="#在持久层接口中添加模糊查询方法" class="headerlink" title="在持久层接口中添加模糊查询方法"></a>在持久层接口中添加模糊查询方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据名字模糊查询</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;User&gt; findByName(String username);</span><br></pre></td></tr></table></figure>

<h3 id="在用户的映射配置文件中配置-4"><a href="#在用户的映射配置文件中配置-4" class="headerlink" title="在用户的映射配置文件中配置"></a>在用户的映射配置文件中配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据名字模糊查询--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findByName&quot; resultType&#x3D;&quot;com.syx.domain.User&quot; parameterType&#x3D;&quot;String&quot;&gt;</span><br><span class="line">    select * from user where username like #&#123;username&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="测试方法-1"><a href="#测试方法-1" class="headerlink" title="测试方法"></a>测试方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void findByName()&#123;</span><br><span class="line">    List&lt;User&gt; userList &#x3D; userDao.findByName(&quot;%王%&quot;);</span><br><span class="line">    for (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询使用聚合函数"><a href="#查询使用聚合函数" class="headerlink" title="查询使用聚合函数"></a>查询使用聚合函数</h2><h3 id="在持久层接口中添加模糊查询方法-1"><a href="#在持久层接口中添加模糊查询方法-1" class="headerlink" title="在持久层接口中添加模糊查询方法"></a>在持久层接口中添加模糊查询方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查询总记录数</span><br><span class="line"> *&#x2F;</span><br><span class="line">int findTotal();</span><br></pre></td></tr></table></figure>

<h3 id="在用户的映射配置文件中配置-5"><a href="#在用户的映射配置文件中配置-5" class="headerlink" title="在用户的映射配置文件中配置"></a>在用户的映射配置文件中配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--查询总记录条数 --&gt;</span><br><span class="line"> &lt;select id&#x3D;&quot;findTotal&quot; resultType&#x3D;&quot;Integer&quot;&gt;</span><br><span class="line">     select count(*) from user</span><br><span class="line"> &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加入聚合查询的测试方法"><a href="#加入聚合查询的测试方法" class="headerlink" title="加入聚合查询的测试方法"></a>加入聚合查询的测试方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public  void findTotal()&#123;</span><br><span class="line">    int total &#x3D; userDao.findTotal();</span><br><span class="line">    System.out.println(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（一）</title>
    <url>/2020/03/27/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="MyBatis学习笔记（一）"><a href="#MyBatis学习笔记（一）" class="headerlink" title="MyBatis学习笔记（一）"></a><center>MyBatis学习笔记（一）</center></h1><h2 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h2><p>mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</p>
<p>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p>
<p>采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。  </p>
<h2 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h2><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><p>创建 mybatis01 的工程，工程信息如下：<br>Groupid:com.syx<br>ArtifactId:mybatis<br>Packing:jar  </p>
<h3 id="添加Mybatis坐标"><a href="#添加Mybatis坐标" class="headerlink" title="添加Mybatis坐标"></a>添加Mybatis坐标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写User实体类"><a href="#编写User实体类" class="headerlink" title="编写User实体类"></a>编写User实体类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private  Integer id;</span><br><span class="line">    private  String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private  String sex;</span><br><span class="line">    private  String address;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, birthday&#x3D;&quot; + birthday +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写持久层接口IUserDao"><a href="#编写持久层接口IUserDao" class="headerlink" title="编写持久层接口IUserDao"></a>编写持久层接口IUserDao</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 用户持久层接口</span><br><span class="line">* *&#x2F;</span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写持久层接口映射文件IUserDao-xml"><a href="#编写持久层接口映射文件IUserDao-xml" class="headerlink" title="编写持久层接口映射文件IUserDao.xml"></a>编写持久层接口映射文件IUserDao.xml</h3><p>要求：</p>
<ul>
<li>创建位置： 必须和持久层接口在相同的包中。</li>
<li>名称： 必须以持久层接口名称命名文件名，扩展名是.xml  </li>
</ul>
<p><img src="/" class="lazyload" data-src="/img/Mybatis/1.png"  alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"> &lt;mapper namespace&#x3D;&quot;com.syx.dao.IUserDao&quot;&gt;</span><br><span class="line">    &lt;!-- 配置查询所有--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;com.syx.domain.User&quot;&gt;</span><br><span class="line">        select  * from user</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写SqlMapConfig-xml-主配置文件"><a href="#编写SqlMapConfig-xml-主配置文件" class="headerlink" title="编写SqlMapConfig.xml 主配置文件"></a>编写SqlMapConfig.xml 主配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--配置环境 --&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">        &lt;!-- 配置mysql环境--&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">            &lt;!-- 配置事务类型--&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源(连接池) --&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立配置的文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;com&#x2F;syx&#x2F;dao&#x2F;IUserDao.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    public static void main(String[] args) throws   Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">        InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建SqlSessionFactory工厂</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;3.试用工厂创建SqlSession对象</span><br><span class="line">        SqlSession sqlSession &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;4.使用SqlSession创建Dao接口的代理对象</span><br><span class="line">        IUserDao dao &#x3D; sqlSession.getMapper(IUserDao.class);</span><br><span class="line">        &#x2F;&#x2F;5.使用代理对象执行方法</span><br><span class="line">        List&lt;User&gt; userList &#x3D; dao.findAll();</span><br><span class="line">        for (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;6.释放资源</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库搭建"><a href="#数据库搭建" class="headerlink" title="数据库搭建"></a>数据库搭建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL auto_increment,</span><br><span class="line">  &#96;username&#96; varchar(32) NOT NULL COMMENT &#39;用户名称&#39;,</span><br><span class="line">  &#96;birthday&#96; datetime default NULL COMMENT &#39;生日&#39;,</span><br><span class="line">  &#96;sex&#96; char(1) default NULL COMMENT &#39;性别&#39;,</span><br><span class="line">  &#96;address&#96; varchar(256) default NULL COMMENT &#39;地址&#39;,</span><br><span class="line">  PRIMARY KEY  (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">insert  into &#96;user&#96;(&#96;id&#96;,&#96;username&#96;,&#96;birthday&#96;,&#96;sex&#96;,&#96;address&#96;) values (41,&#39;老王&#39;,&#39;2018-02-27 17:47:08&#39;,&#39;男&#39;,&#39;北京&#39;),(42,&#39;小二王&#39;,&#39;2018-03-02 15:09:37&#39;,&#39;女&#39;,&#39;北京金燕龙&#39;),(43,&#39;小二王&#39;,&#39;2018-03-04 11:34:34&#39;,&#39;女&#39;,&#39;北京金燕龙&#39;),(45,&#39;a&#39;,&#39;2018-03-04 12:04:06&#39;,&#39;男&#39;,&#39;北京金燕龙&#39;),(46,&#39;老王&#39;,&#39;2018-03-07 17:37:26&#39;,&#39;男&#39;,&#39;北京&#39;),(48,&#39;小马宝莉&#39;,&#39;2018-03-08 11:44:00&#39;,&#39;女&#39;,&#39;北京修正&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="补充（基于注解的-mybatis-使用）"><a href="#补充（基于注解的-mybatis-使用）" class="headerlink" title="补充（基于注解的 mybatis 使用）"></a>补充（基于注解的 mybatis 使用）</h3><h4 id="在持久层接口中添加注解"><a href="#在持久层接口中添加注解" class="headerlink" title="在持久层接口中添加注解"></a>在持久层接口中添加注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 用户持久层接口</span><br><span class="line">* *&#x2F;</span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Select(&quot;select * from user&quot;)</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改-SqlMapConfig-xml"><a href="#修改-SqlMapConfig-xml" class="headerlink" title="修改 SqlMapConfig.xml"></a>修改 SqlMapConfig.xml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立配置的文件--&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;mapper class&#x3D;&quot;com.syx.dao.IUserDao&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote>
<p>在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml）。<br>补充  </p>
</blockquote>
]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（五）</title>
    <url>/2020/03/31/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（五）"><a href="#Mybatis学习笔记（五）" class="headerlink" title="Mybatis学习笔记（五）"></a><center>Mybatis学习笔记（五）</center></h1><h2 id="Mybatis-延迟加载策略"><a href="#Mybatis-延迟加载策略" class="headerlink" title="Mybatis 延迟加载策略"></a>Mybatis 延迟加载策略</h2><h3 id="何为延迟加载"><a href="#何为延迟加载" class="headerlink" title="何为延迟加载?"></a>何为延迟加载?</h3><blockquote>
<p>延迟加载：<br>就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.<br>好处： 先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。<br>坏处：<br>因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗<br>时间，所以可能造成用户等待时间变长，造成用户体验下降  </p>
</blockquote>
<h3 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h3><blockquote>
<p>需求：<br>查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要<br>求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加<br>载。  </p>
</blockquote>
<h3 id="使用-assocation-实现延迟加载"><a href="#使用-assocation-实现延迟加载" class="headerlink" title="使用 assocation 实现延迟加载"></a>使用 assocation 实现延迟加载</h3><p>账户的持久层 DAO 接口  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Account&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>账户的持久层映射文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IAccountDao&quot;&gt;</span><br><span class="line">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;accountUserMao&quot; type&#x3D;&quot;account&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;money&quot; column&#x3D;&quot;money&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--一对一关系映射，配置User的内容--&gt;</span><br><span class="line">        &lt;association property&#x3D;&quot;user&quot; column&#x3D;&quot;uid&quot; javaType&#x3D;&quot;user&quot; select&#x3D;&quot;com.syx.dao.IUserDao.findById&quot;&gt;</span><br><span class="line">        &lt;&#x2F;association&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;accountUserMao&quot;&gt;</span><br><span class="line">    SELECT * from  account</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAccountByUid&quot; resultType&#x3D;&quot;account&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">        select * from account where uid&#x3D; #&#123;uid&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p><strong>select</strong>： 填写我们要调用的 select 映射的 id<br><strong>column</strong> ： 填写我们要传递给 select 映射的参数  </p>
<p>用户的持久层接口和映射文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据Id查询--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;com.syx.domain.User&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">       select * from user  where id &#x3D; #&#123;uid&#125;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>开启 Mybatis 的延迟加载策略  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置参数--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启延迟加载的全局开关--&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;aggressiveLazyLoading&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h2><h3 id="Mybatis-一级缓存"><a href="#Mybatis-一级缓存" class="headerlink" title="Mybatis 一级缓存"></a>Mybatis 一级缓存</h3><blockquote>
<p>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除， commit()， close()等  方法时，就会清空一级缓存。  </p>
</blockquote>
<h3 id="Mybatis-二级缓存"><a href="#Mybatis-二级缓存" class="headerlink" title="Mybatis 二级缓存"></a>Mybatis 二级缓存</h3><p>二级缓存的开启与关闭 :</p>
<p>第一步：在 SqlMapConfig.xml 文件开启二级缓存  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br><span class="line">因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为</span><br><span class="line">false 代表不开启二级缓存</span><br></pre></td></tr></table></figure>

<p>第二步：配置相关的 Mapper 映射文件 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.itheima.dao.IUserDao&quot;&gt;</span><br><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;cache&gt;&lt;&#x2F;cache&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>第三步： 配置 statement 上面的 useCache 属性  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据 id 查询 --&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;int&quot; useCache&#x3D;&quot;true&quot;&gt;</span><br><span class="line">select * from user where id &#x3D; #&#123;uid&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache&#x3D;”true”代表当前这个 statement 要使用</span><br><span class="line">二级缓存，如果不使用二级缓存可以设置为 false。</span><br><span class="line">注意： 针对每次查询都需要最新的数据 sql，要设置成 useCache&#x3D;false，禁用二级缓存。</span><br></pre></td></tr></table></figure>

<h2 id="使用注解实现复杂关系映射开发"><a href="#使用注解实现复杂关系映射开发" class="headerlink" title="使用注解实现复杂关系映射开发"></a>使用注解实现复杂关系映射开发</h2><h3 id="复杂关系映射的注解说明"><a href="#复杂关系映射的注解说明" class="headerlink" title="复杂关系映射的注解说明"></a>复杂关系映射的注解说明</h3><blockquote>
<p>@Results 注解<br>代替的是标签<resultMap><br>该注解中可以使用单个@Result 注解，也可以使用@Result 集合<br>@Results（{@Result（）， @Result（） }）或@Results（@Result（））<br>@Resutl 注解<br>代替了 <id>标签和<result>标签<br>@Result 中 属性介绍：<br>id 是否是主键字段<br>column 数据库的列名<br>property 需要装配的属性名</p>
<p>one 需要使用的@One 注解（@Result（one=@One）（）））</p>
<p>many 需要使用的@Many 注解（@Result（many=@many）（）））</p>
<p>@One 注解（一对一）<br>代替了<assocation>标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。<br>@One 注解属性介绍：<br>select 指定用来多表查询的 sqlmapper<br>fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。<br>使用格式：<br>@Result(column=” “,property=””,one=@One(select=””))<br>@Many 注解（多对一）<br>代替了<Collection>标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。<br>注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType<br>（一般为 ArrayList）但是注解中可以不定义；<br>使用格式：<br>@Result(property=””,column=””,many=@Many(select=””))</p>
</blockquote>
<h3 id="使用注解实现一对一复杂关系映射及延迟加载"><a href="#使用注解实现一对一复杂关系映射及延迟加载" class="headerlink" title="使用注解实现一对一复杂关系映射及延迟加载"></a>使用注解实现一对一复杂关系映射及延迟加载</h3><p>添加 User 实体类及 Account 实体类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">private Integer userId;</span><br><span class="line">private String userName;</span><br><span class="line">private Date userBirthday;</span><br><span class="line">private String userSex;</span><br><span class="line">private String userAddress;</span><br><span class="line">public Integer getUserId() &#123;</span><br><span class="line">return userId;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserId(Integer userId) &#123;</span><br><span class="line">this.userId &#x3D; userId;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserName() &#123;</span><br><span class="line">return userName;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserName(String userName) &#123;</span><br><span class="line">this.userName &#x3D; userName;</span><br><span class="line">&#125;</span><br><span class="line">public Date getUserBirthday() &#123;</span><br><span class="line">return userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserBirthday(Date userBirthday) &#123;</span><br><span class="line">this.userBirthday &#x3D; userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserSex() &#123;</span><br><span class="line">return userSex;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserSex(String userSex) &#123;</span><br><span class="line">this.userSex &#x3D; userSex;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserAddress() &#123;</span><br><span class="line">return userAddress;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserAddress(String userAddress) &#123;</span><br><span class="line">this.userAddress &#x3D; userAddress;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;User [userId&#x3D;&quot; + userId + &quot;, userName&#x3D;&quot; + userName + &quot;, userBirthday&#x3D;&quot;</span><br><span class="line">+ userBirthday + &quot;, userSex&#x3D;&quot;</span><br><span class="line">+ userSex + &quot;, userAddress&#x3D;&quot; + userAddress + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account implements Serializable &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private Integer uid;</span><br><span class="line">private Double money;</span><br><span class="line">&#x2F;&#x2F;多对一关系映射：从表方应该包含一个主表方的对象引用</span><br><span class="line">private User user;</span><br><span class="line">public User getUser() &#123;</span><br><span class="line">return user;</span><br><span class="line">&#125;</span><br><span class="line">public void setUser(User user) &#123;</span><br><span class="line">this.user &#x3D; user;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(Integer id) &#123;</span><br><span class="line">this.id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getUid() &#123;</span><br><span class="line">return uid;</span><br><span class="line">&#125;</span><br><span class="line">public void setUid(Integer uid) &#123;this.uid &#x3D; uid;</span><br><span class="line">&#125;</span><br><span class="line">public Double getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line">public void setMoney(Double money) &#123;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Account [id&#x3D;&quot; + id + &quot;, uid&#x3D;&quot; + uid + &quot;, money&#x3D;&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加账户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 查询所有账户，采用延迟加载的方式查询账户的所属用户</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from account&quot;)</span><br><span class="line">@Results(id&#x3D;&quot;accountMap&quot;,</span><br><span class="line">value&#x3D; &#123;</span><br><span class="line">@Result(id&#x3D;true,column&#x3D;&quot;id&quot;,property&#x3D;&quot;id&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;uid&quot;,property&#x3D;&quot;uid&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;money&quot;,property&#x3D;&quot;money&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;uid&quot;,</span><br><span class="line">property&#x3D;&quot;user&quot;,</span><br><span class="line">one&#x3D;@One(select&#x3D;&quot;com.itheima.dao.IUserDao.findById&quot;,</span><br><span class="line">fetchType&#x3D;FetchType.LAZY)</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Account&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加用户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IUserDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 查询所有用户</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from user&quot;)</span><br><span class="line">@Results(id&#x3D;&quot;userMap&quot;,</span><br><span class="line">value&#x3D; &#123;</span><br><span class="line">@Result(id&#x3D;true,column&#x3D;&quot;id&quot;,property&#x3D;&quot;userId&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;username&quot;,property&#x3D;&quot;userName&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;sex&quot;,property&#x3D;&quot;userSex&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;address&quot;,property&#x3D;&quot;userAddress&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;birthday&quot;,property&#x3D;&quot;userBirthday&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;User&gt; findAll();</span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据 id 查询一个用户</span><br><span class="line">* @param userId</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from user where id &#x3D; #&#123;uid&#125; &quot;)</span><br><span class="line">@ResultMap(&quot;userMap&quot;)</span><br><span class="line">User findById(Integer userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用注解实现一对多复杂关系映射"><a href="#使用注解实现一对多复杂关系映射" class="headerlink" title="使用注解实现一对多复杂关系映射"></a>使用注解实现一对多复杂关系映射</h3><blockquote>
<p> User 实体类加入 List<Account>  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">private Integer userId;</span><br><span class="line">private String userName;</span><br><span class="line">private Date userBirthday;</span><br><span class="line">private String userSex;</span><br><span class="line">private String userAddress;</span><br><span class="line">&#x2F;&#x2F;一对多关系映射：主表方法应该包含一个从表方的集合引用</span><br><span class="line">private List&lt;Account&gt; accounts;</span><br><span class="line">public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">return accounts;</span><br><span class="line">&#125;</span><br><span class="line">public void setAccounts(List&lt;Account&gt; accounts) &#123;this.accounts &#x3D; accounts;</span><br><span class="line">&#125;</span><br><span class="line">public Integer getUserId() &#123;</span><br><span class="line">return userId;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserId(Integer userId) &#123;</span><br><span class="line">this.userId &#x3D; userId;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserName() &#123;</span><br><span class="line">return userName;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserName(String userName) &#123;</span><br><span class="line">this.userName &#x3D; userName;</span><br><span class="line">&#125;</span><br><span class="line">public Date getUserBirthday() &#123;</span><br><span class="line">return userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserBirthday(Date userBirthday) &#123;</span><br><span class="line">this.userBirthday &#x3D; userBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserSex() &#123;</span><br><span class="line">return userSex;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserSex(String userSex) &#123;</span><br><span class="line">this.userSex &#x3D; userSex;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserAddress() &#123;</span><br><span class="line">return userAddress;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserAddress(String userAddress) &#123;</span><br><span class="line">this.userAddress &#x3D; userAddress;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;User [userId&#x3D;&quot; + userId + &quot;, userName&#x3D;&quot; + userName + &quot;, userBirthday&#x3D;&quot;</span><br><span class="line">+ userBirthday + &quot;, userSex&#x3D;&quot;</span><br><span class="line">+ userSex + &quot;, userAddress&#x3D;&quot; + userAddress + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写用户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IUserDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 查询所有用户</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from user&quot;)</span><br><span class="line">@Results(id&#x3D;&quot;userMap&quot;,</span><br><span class="line">value&#x3D; &#123;</span><br><span class="line">@Result(id&#x3D;true,column&#x3D;&quot;id&quot;,property&#x3D;&quot;userId&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;username&quot;,property&#x3D;&quot;userName&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;sex&quot;,property&#x3D;&quot;userSex&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;address&quot;,property&#x3D;&quot;userAddress&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;birthday&quot;,property&#x3D;&quot;userBirthday&quot;),</span><br><span class="line">@Result(column&#x3D;&quot;id&quot;,property&#x3D;&quot;accounts&quot;,</span><br><span class="line">many&#x3D;@Many(</span><br><span class="line">select&#x3D;&quot;com.itheima.dao.IAccountDao.findByUid&quot;,</span><br><span class="line">fetchType&#x3D;FetchType.LAZY</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br><span class="line">@Many:</span><br><span class="line">相当于&lt;collection&gt;的配置</span><br><span class="line">select 属性：代表将要执行的 sql 语句</span><br><span class="line">fetchType 属性：代表加载方式，一般如果要延迟加载都设置为 LAZY 的值</span><br></pre></td></tr></table></figure>

<p>编写账户的持久层接口并使用注解配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据用户 id 查询用户下的所有账户</span><br><span class="line">* @param userId</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Select(&quot;select * from account where uid &#x3D; #&#123;uid&#125; &quot;)</span><br><span class="line">List&lt;Account&gt; findByUid(Integer userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mybatis-基于注解的二级缓存"><a href="#mybatis-基于注解的二级缓存" class="headerlink" title="mybatis 基于注解的二级缓存"></a>mybatis 基于注解的二级缓存</h3><p>在 SqlMapConfig 中开启二级缓存支持  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置二级缓存 --&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<p>在持久层接口中使用注解配置二级缓存  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CacheNamespace(blocking&#x3D;true)&#x2F;&#x2F;mybatis 基于注解方式实现配置二级缓存</span><br><span class="line">public interface IUserDao &#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/04/08/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a><center>SSM整合</center></h1><h2 id="搭建整合环境"><a href="#搭建整合环境" class="headerlink" title="搭建整合环境"></a>搭建整合环境</h2><p>导入坐标依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">      &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">      &lt;spring.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line">      &lt;slf4j.version&gt;1.6.6&lt;&#x2F;slf4j.version&gt;</span><br><span class="line">      &lt;log4j.version&gt;1.2.12&lt;&#x2F;log4j.version&gt;</span><br><span class="line">      &lt;mysql.version&gt;5.1.6&lt;&#x2F;mysql.version&gt;</span><br><span class="line">      &lt;mybatis.version&gt;3.4.5&lt;&#x2F;mybatis.version&gt;</span><br><span class="line">  &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;!-- spring --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.5&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.0&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- log start --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;log4j.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;slf4j.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;slf4j.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- log end --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;mybatis.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="搭建和测试Spring的开发环境"><a href="#搭建和测试Spring的开发环境" class="headerlink" title="搭建和测试Spring的开发环境"></a>搭建和测试Spring的开发环境</h2><p>在ssm项目中创建applicationContext.xml的配置文件，编写具体的配置信息。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;</span><br><span class="line">?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 开启注解扫描，要扫描的是service和dao层的注解，要忽略web层注解，因为web层让SpringMVC框架</span><br><span class="line">去管理 --&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;cn.syx&quot;&gt;</span><br><span class="line">&lt;!-- 配置要忽略的注解 --&gt;</span><br><span class="line">&lt;context:exclude-filter type&#x3D;&quot;annotation&quot;</span><br><span class="line">expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h2 id="搭建和测试SpringMVC的开发环境"><a href="#搭建和测试SpringMVC的开发环境" class="headerlink" title="搭建和测试SpringMVC的开发环境"></a>搭建和测试SpringMVC的开发环境</h2><p>在web.xml中配置DispatcherServlet前端控制器  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置前端控制器：服务器启动必须加载，需要加载springmvc.xml配置文件 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>在web.xml中配置DispatcherServlet过滤器解决中文乱码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置解决中文乱码的过滤器 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">&lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>创建springmvc.xml的配置文件，编写配置文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 扫描controller的注解，别的不扫描 --&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;cn.syx&quot;&gt;</span><br><span class="line">&lt;context:include-filter type&#x3D;&quot;annotation&quot;</span><br><span class="line">expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;viewResolver&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;!-- JSP文件所在的目录 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 文件的后缀名 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 设置静态资源不过滤 --&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;css&#x2F;&quot; mapping&#x3D;&quot;&#x2F;css&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;images&#x2F;&quot; mapping&#x3D;&quot;&#x2F;images&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;js&#x2F;&quot; mapping&#x3D;&quot;&#x2F;js&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 开启对SpringMVC注解的支持 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring整合SpringMVC的框架"><a href="#Spring整合SpringMVC的框架" class="headerlink" title="Spring整合SpringMVC的框架"></a>Spring整合SpringMVC的框架</h2><p>在项目启动的时候，就去加载applicationContext.xml的配置文件，在web.xml中配置ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文件）。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置Spring的监听器 --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listenerclass&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br><span class="line">&lt;!-- 配置加载类路径的配置文件 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring整合MyBatis框架"><a href="#Spring整合MyBatis框架" class="headerlink" title="Spring整合MyBatis框架"></a>Spring整合MyBatis框架</h2><h3 id="搭建和测试MyBatis的环境"><a href="#搭建和测试MyBatis的环境" class="headerlink" title="搭建和测试MyBatis的环境"></a>搭建和测试MyBatis的环境</h3><p>在web项目中编写SqlMapConfig.xml的配置文件，编写核心配置文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;environments default&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">&lt;environment id&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">&lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dataSource&gt;</span><br><span class="line">&lt;&#x2F;environment&gt;</span><br><span class="line">&lt;&#x2F;environments&gt;</span><br><span class="line">&lt;!-- 使用的是注解 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;!-- &lt;mapper class&#x3D;&quot;cn.itcast.dao.AccountDao&quot;&#x2F;&gt; --&gt;</span><br><span class="line">&lt;!-- 该包下所有的dao接口都可以使用 --&gt;</span><br><span class="line">&lt;package name&#x3D;&quot;cn.syx.dao&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Spring整合MyBatis框架-1"><a href="#Spring整合MyBatis框架-1" class="headerlink" title="Spring整合MyBatis框架"></a>Spring整合MyBatis框架</h3><p>目的：把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置C3P0的连接池对象 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 配置SqlSession的工厂 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 配置扫描dao的包 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;mapperScanner&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;cn.itcast.dao&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置Spring的声明式事务管理"><a href="#配置Spring的声明式事务管理" class="headerlink" title="配置Spring的声明式事务管理"></a>配置Spring的声明式事务管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置Spring框架声明式事务管理--&gt;</span><br><span class="line">   &lt;!--配置事务管理器--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">   &lt;!--配置事务通知--&gt;</span><br><span class="line">   &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;</span><br><span class="line">   &lt;tx:attributes&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;find*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">       &lt;tx:method name&#x3D;&quot;*&quot; isolation&#x3D;&quot;DEFAULT&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">   &lt;&#x2F;tx:advice&gt;</span><br><span class="line">   &lt;!--配置AOP增强--&gt;</span><br><span class="line">   &lt;aop:config&gt;</span><br><span class="line">&lt;!-- 配置切入点表达式 --&gt;</span><br><span class="line">       &lt;aop:pointcut expression&#x3D;&quot;execution(* com.syx.service.Impl.*.*(..))&quot; id&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">       &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记（四）</title>
    <url>/2020/03/30/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Mybatis学习笔记（四）"><a href="#Mybatis学习笔记（四）" class="headerlink" title="Mybatis学习笔记（四）"></a><center>Mybatis学习笔记（四）</center></h1><h2 id="Mybatis的动态语句"><a href="#Mybatis的动态语句" class="headerlink" title="Mybatis的动态语句"></a>Mybatis的动态语句</h2><h3 id="动态-SQL-之if标签"><a href="#动态-SQL-之if标签" class="headerlink" title="动态 SQL 之if标签"></a>动态 SQL 之if标签</h3><p>持久层 Dao 接口 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *根据传入参数条件，有可能有用户名、性别、地址，也可能全有</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;User&gt; findUserByCondition(User user);</span><br></pre></td></tr></table></figure>

<p>持久层 Dao 映射配置  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--根据传入参数查询--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;findUserByCondition&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">       select * from user and 1 &#x3D; 1</span><br><span class="line">       &lt;if test&#x3D;&quot;username!&#x3D;null&quot;&gt;</span><br><span class="line">           and username &#x3D; #&#123;username&#125;</span><br><span class="line">       &lt;&#x2F;if&gt;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>测试  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public  void findUserByCondition()&#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUsername(&quot;老王&quot;);</span><br><span class="line">        List&lt;User&gt; userList &#x3D; userDao.findUserByCondition(user);</span><br><span class="line">        for (User user1 : userList) &#123;</span><br><span class="line">            System.out.println(user1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态-SQL-之where标签"><a href="#动态-SQL-之where标签" class="headerlink" title="动态 SQL 之where标签"></a>动态 SQL 之where标签</h3><p>持久层 Dao 映射配置  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--根据传入参数查询--&gt;</span><br><span class="line">   &lt;select id&#x3D;&quot;findUserByCondition&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">       select * from user</span><br><span class="line">       &lt;where&gt;</span><br><span class="line">       &lt;if test&#x3D;&quot;username!&#x3D;null&quot;&gt;</span><br><span class="line">           and username &#x3D; #&#123;username&#125;</span><br><span class="line">       &lt;&#x2F;if&gt;</span><br><span class="line">       &lt;if test&#x3D;&quot;sex!&#x3D;null&quot;&gt;</span><br><span class="line">           and sex &#x3D; #&#123;sex&#125;</span><br><span class="line">       &lt;&#x2F;if&gt;</span><br><span class="line">       &lt;&#x2F;where&gt;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态标签之foreach标签"><a href="#动态标签之foreach标签" class="headerlink" title="动态标签之foreach标签"></a>动态标签之foreach标签</h3><p>QueryVo对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QueryVo &#123;</span><br><span class="line">    private User user;</span><br><span class="line">    private List&lt;Integer&gt; ids;</span><br><span class="line"></span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; getIds() &#123;</span><br><span class="line">        return ids;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setIds(List&lt;Integer&gt; ids) &#123;</span><br><span class="line">        this.ids &#x3D; ids;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>持久层 Dao 接口 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *根据 QueryVo提供的Ids查询用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;User&gt; findUserInIds(QueryVo queryVo);</span><br></pre></td></tr></table></figure>

<p>持久层 Dao 映射配置  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--根据Ids查询--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findUserInIds&quot; parameterType&#x3D;&quot;queryvo&quot; resultType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test&#x3D;&quot;ids!&#x3D;null and ids.size()&gt;0&quot;&gt;</span><br><span class="line">            &lt;foreach collection&#x3D;&quot;ids&quot; open&#x3D;&quot;id in (&quot; close&#x3D;&quot;)&quot; item&#x3D;&quot;id&quot; separator&#x3D;&quot;,&quot;&gt;</span><br><span class="line">                #&#123;id&#125;</span><br><span class="line">            &lt;&#x2F;foreach&gt;</span><br><span class="line">        &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;&#x2F;where&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void findUserInIds()&#123;</span><br><span class="line">        QueryVo queryVo &#x3D; new QueryVo();</span><br><span class="line">        List&lt;Integer&gt; ids &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        ids.add(41);</span><br><span class="line">        ids.add(42);</span><br><span class="line">        ids.add(43);</span><br><span class="line">        queryVo.setIds(ids);</span><br><span class="line">        List&lt;User&gt; userList &#x3D; userDao.findUserInIds(queryVo);</span><br><span class="line">        for (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis-中简化编写的-SQL-片段"><a href="#Mybatis-中简化编写的-SQL-片段" class="headerlink" title="Mybatis 中简化编写的 SQL 片段"></a>Mybatis 中简化编写的 SQL 片段</h2><blockquote>
<p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。  </p>
</blockquote>
<p>定义代码片段  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 抽取重复的语句代码片段 --&gt;</span><br><span class="line">&lt;sql id&#x3D;&quot;defaultSql&quot;&gt;</span><br><span class="line">select * from user</span><br><span class="line">&lt;&#x2F;sql&gt;</span><br></pre></td></tr></table></figure>

<p>引用代码片段  :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置查询所有操作 --&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">&lt;include refid&#x3D;&quot;defaultSql&quot;&gt;&lt;&#x2F;include&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis-多表查询之一对多"><a href="#Mybatis-多表查询之一对多" class="headerlink" title="Mybatis 多表查询之一对多"></a>Mybatis 多表查询之一对多</h2><h3 id="一对一查询-多对一"><a href="#一对一查询-多对一" class="headerlink" title="一对一查询(多对一)"></a>一对一查询(多对一)</h3><blockquote>
<p>使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。<br>通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户<br>是哪个用户的。  </p>
</blockquote>
<p>Account 类  ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private Integer uid;</span><br><span class="line">    private double money;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getUid() &#123;</span><br><span class="line">        return uid;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUid(Integer uid) &#123;</span><br><span class="line">        this.uid &#x3D; uid;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMoney(double money) &#123;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user &#x3D; user;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Account&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, uid&#x3D;&quot; + uid +</span><br><span class="line">                &quot;, money&#x3D;&quot; + money +</span><br><span class="line">                &quot;, user&#x3D;&quot; + user +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AccountDao 接口中的方法 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查询所有</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;Account&gt; findAll();</span><br></pre></td></tr></table></figure>

<p>AccountDao.xml 文件 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IAccountDao&quot;&gt;</span><br><span class="line">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;accountUserMao&quot; type&#x3D;&quot;account&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;aid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;money&quot; column&#x3D;&quot;money&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--一对一关系映射，配置User的内容--&gt;</span><br><span class="line">        &lt;association property&#x3D;&quot;user&quot; column&#x3D;&quot;uid&quot; javaType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;association&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;accountUserMao&quot;&gt;</span><br><span class="line">    SELECT u.*,a.id as aid,a.uid,a.money FROM USER u,account a WHERE u.id &#x3D; a.UID</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试方法 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void findAll()&#123;</span><br><span class="line">      List&lt;Account&gt; accountList &#x3D; accountDao.findAll();</span><br><span class="line">      for (Account account : accountList) &#123;</span><br><span class="line">          System.out.println(account);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><p>编写 SQL 语句 :</p>
<blockquote>
<p>SELECT * FROM USER u LEFT OUTER JOIN account a ON u.id = a.uid </p>
</blockquote>
<p>User 类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private  Integer id;</span><br><span class="line">    private  String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private  String sex;</span><br><span class="line">    private  String address;</span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line">    &#x2F;&#x2F;一对多关系映射，主表实体应该包含从表实体的集合引用</span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts &#x3D; accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, birthday&#x3D;&quot; + birthday +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户持久层 Dao 映射文件配置 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IUserDao&quot;&gt;</span><br><span class="line">    &lt;!--定义user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;userAccountMap&quot; type&#x3D;&quot;user&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;collection property&#x3D;&quot;accounts&quot; ofType&#x3D;&quot;account&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;aid&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;uid&quot; column&#x3D;&quot;uid&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;money&quot; column&#x3D;&quot;money&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;collection&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">    &lt;!-- 配置查询所有--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;userAccountMap&quot;&gt;</span><br><span class="line">       SELECT * FROM USER u LEFT OUTER JOIN account a ON u.id &#x3D; a.uid</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    private InputStream in ;</span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">       in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建构建者对象</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        &#x2F;&#x2F; 3.创建SqlSession工厂对象</span><br><span class="line">         factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;4.创建SqlSession对向</span><br><span class="line">        session &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;5.创建Dao代理对象</span><br><span class="line">        userDao &#x3D; session.getMapper(IUserDao.class);</span><br><span class="line">        &#125;</span><br><span class="line">        @After</span><br><span class="line">        public void destroy() throws Exception&#123;</span><br><span class="line">            session.commit();</span><br><span class="line">            &#x2F;&#x2F;7.释放资源</span><br><span class="line">            session.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        @Test</span><br><span class="line">        public void findAll()&#123;</span><br><span class="line">            List&lt;User&gt; userList &#x3D; userDao.findAll();</span><br><span class="line">            for (User user : userList) &#123;</span><br><span class="line">                System.out.println(&quot;------------每个用户信息&quot;);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">                System.out.println(user.getAccounts());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis-多表查询之多对多"><a href="#Mybatis-多表查询之多对多" class="headerlink" title="Mybatis 多表查询之多对多"></a>Mybatis 多表查询之多对多</h2><h3 id="实现-Role-到-User-多对多"><a href="#实现-Role-到-User-多对多" class="headerlink" title="实现 Role 到 User 多对多"></a>实现 Role 到 User 多对多</h3><p>业务要求及实现 SQL  </p>
<blockquote>
<p>需求：<br>实现查询所有对象并且加载它所分配的用户信息。<br>分析：<br>查询角色我们需要用到Role表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中<br>间表(USER_ROLE 表)才能关联到用户信息。<br>下面是实现的 SQL 语句：<br>SELECT<br>r.*,u.id uid,<br>u.username username,<br>u.birthday birthday,<br>u.sex sex,<br>u.address address<br>FROM<br>ROLE r<br>INNER JOIN<br>USER_ROLE ur<br>ON ( r.id = ur.rid)<br>INNER JOIN<br>USER u<br>ON (ur.uid = u.id);  </p>
</blockquote>
<p>编写角色实体类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Role &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String  rolename;</span><br><span class="line">    private String roledesc;</span><br><span class="line">    private List&lt;User&gt; users;</span><br><span class="line"></span><br><span class="line">    public List&lt;User&gt; getUsers() &#123;</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        this.users &#x3D; users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRolename() &#123;</span><br><span class="line">        return rolename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRolename(String rolename) &#123;</span><br><span class="line">        this.rolename &#x3D; rolename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRoledesc() &#123;</span><br><span class="line">        return roledesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoledesc(String roledesc) &#123;</span><br><span class="line">        this.roledesc &#x3D; roledesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Role&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, rolename&#x3D;&#39;&quot; + rolename + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, roledesc&#x3D;&#39;&quot; + roledesc + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写 Role 持久层接口 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRoleDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有角色</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Role&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写映射文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IRoleDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;RoleMap&quot; type&#x3D;&quot;role&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;rid&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;rolename&quot; column&#x3D;&quot;role_name&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;roledesc&quot; column&#x3D;&quot;role_desc&quot;&#x2F;&gt;</span><br><span class="line">        &lt;collection property&#x3D;&quot;users&quot; ofType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;collection&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;RoleMap&quot;&gt;</span><br><span class="line">        SELECT u.*,r.id AS rid,r.role_name,r.role_desc FROM role r</span><br><span class="line">        LEFT OUTER JOIN user_role ur ON r.id &#x3D; ur.rid</span><br><span class="line">        LEFT OUTER JOIN USER u ON u.id &#x3D; ur.uid</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>编写测试类 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"> public void findAll()&#123;</span><br><span class="line">     List&lt;Role&gt; roleList &#x3D; roleDao.findAll();</span><br><span class="line">     for (Role role : roleList) &#123;</span><br><span class="line">         System.out.println(role);</span><br><span class="line">         System.out.println(role.getUsers());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-User-到-Role-的多对多"><a href="#实现-User-到-Role-的多对多" class="headerlink" title="实现 User 到 Role 的多对多"></a>实现 User 到 Role 的多对多</h3><p>User 到 Role 的多对多  </p>
<blockquote>
<p>从 User 出发，我们也可以发现一个用户可以具有多个角色，这样用户到角色的关系也还是一对多关系。这样<br>我们就可以认为 User 与 Role 的多对多关系，可以被拆解成两个一对多关系来实现。  </p>
</blockquote>
<p>SQL </p>
<blockquote>
<p>SELECT u.*,r.id AS rid,r.role_name,r.role_desc FROM USER u<br>LEFT OUTER JOIN user_role ur ON u.id = ur.uid<br> LEFT OUTER JOIN role r ON r.id = ur.rid</p>
</blockquote>
<p>编写角色实体类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private  Integer id;</span><br><span class="line">    private  String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private  String sex;</span><br><span class="line">    private  String address;</span><br><span class="line">    &#x2F;&#x2F;一对多关系映射，主表实体应该包含从表实体的集合引用</span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line">    private List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    public List&lt;Role&gt; getRoles() &#123;</span><br><span class="line">        return roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoles(List&lt;Role&gt; roles) &#123;</span><br><span class="line">        this.roles &#x3D; roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts &#x3D; accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, birthday&#x3D;&quot; + birthday +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写映射文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.syx.dao.IUserDao&quot;&gt;</span><br><span class="line">    &lt;!--定义user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;userRoleMap&quot; type&#x3D;&quot;user&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;collection property&#x3D;&quot;roles&quot; ofType&#x3D;&quot;role&quot;&gt;</span><br><span class="line">            &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;rid&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;rolename&quot; column&#x3D;&quot;role_name&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result property&#x3D;&quot;roledesc&quot; column&#x3D;&quot;role_desc&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;collection&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">    &lt;!-- 配置查询所有--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;userRoleMap&quot;&gt;</span><br><span class="line">      SELECT u.*,r.id AS rid,r.role_name,r.role_desc FROM USER u</span><br><span class="line">      LEFT OUTER JOIN user_role ur ON u.id &#x3D; ur.uid</span><br><span class="line">      LEFT OUTER JOIN role r ON r.id &#x3D; ur.rid</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>编写测试类 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line">    private InputStream in ;</span><br><span class="line">    private SqlSessionFactory factory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserDao userDao;</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">       in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建构建者对象</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        &#x2F;&#x2F; 3.创建SqlSession工厂对象</span><br><span class="line">         factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;4.创建SqlSession对向</span><br><span class="line">        session &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;5.创建Dao代理对象</span><br><span class="line">        userDao &#x3D; session.getMapper(IUserDao.class);</span><br><span class="line">        &#125;</span><br><span class="line">        @After</span><br><span class="line">        public void destroy() throws Exception&#123;</span><br><span class="line">            session.commit();</span><br><span class="line">            &#x2F;&#x2F;7.释放资源</span><br><span class="line">            session.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        @Test</span><br><span class="line">        public void findAll()&#123;</span><br><span class="line">            List&lt;User&gt; userList &#x3D; userDao.findAll();</span><br><span class="line">            for (User user : userList) &#123;</span><br><span class="line">                System.out.println(&quot;------------每个用户信息&quot;);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">                System.out.println(user.getRoles());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SprimgMvc（二）</title>
    <url>/2020/04/07/SprimgMvc%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a><center>响应数据和结果视图</center></h1><h2 id="返回值分类"><a href="#返回值分类" class="headerlink" title="返回值分类"></a>返回值分类</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;hello&quot;)</span><br><span class="line">public String sayHello() &#123;</span><br><span class="line">System.out.println(&quot;Hello SpringMVC!!&quot;);</span><br><span class="line">&#x2F;&#x2F; 跳转到XX页面</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值是void"><a href="#返回值是void" class="headerlink" title="返回值是void"></a>返回值是void</h3><p>如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。  </p>
<p>默认会跳转到@RequestMapping(value=”/initUpdate”) initUpdate的页面。  </p>
<p>可以使用请求转发或者重定向跳转到指定的页面  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;initAdd&quot;)</span><br><span class="line">public void initAdd(HttpServletRequest request,HttpServletResponse response) throws</span><br><span class="line">Exception &#123;</span><br><span class="line">System.out.println(&quot;请求转发或者重定向&quot;);</span><br><span class="line">&#x2F;&#x2F; 请求转发</span><br><span class="line">&#x2F;&#x2F; request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;add.jsp&quot;).forward(request,</span><br><span class="line">response);</span><br><span class="line">&#x2F;&#x2F; 重定向</span><br><span class="line">&#x2F;&#x2F; response.sendRedirect(request.getContextPath()+&quot;&#x2F;add2.jsp&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line">&#x2F;&#x2F; 直接响应数据</span><br><span class="line">response.getWriter().print(&quot;你好&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值是ModelAndView对象"><a href="#返回值是ModelAndView对象" class="headerlink" title="返回值是ModelAndView对象"></a>返回值是ModelAndView对象</h3><p>ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;</span><br><span class="line">**</span><br><span class="line">* 返回ModelAndView对象</span><br><span class="line">* 可以传入视图的名称（即跳转的页面），还可以传入对象。</span><br><span class="line">* @return</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;findAll&quot;)</span><br><span class="line">public ModelAndView findAll() throws Exception &#123;</span><br><span class="line">ModelAndView mv &#x3D; new ModelAndView();</span><br><span class="line">&#x2F;&#x2F; 跳转到list.jsp的页面</span><br><span class="line">mv.setViewName(&quot;list&quot;);</span><br><span class="line">&#x2F;&#x2F; 模拟从数据库中查询所有的用户信息</span><br><span class="line">List&lt;User&gt; users &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">User user1 &#x3D; new User();</span><br><span class="line">user1.setUsername(&quot;张三&quot;);</span><br><span class="line">user1.setPassword(&quot;123&quot;);</span><br><span class="line">User user2 &#x3D; new User();</span><br><span class="line">user2.setUsername(&quot;赵四&quot;);</span><br><span class="line">user2.setPassword(&quot;456&quot;);</span><br><span class="line">users.add(user1);</span><br><span class="line">users.add(user2);</span><br><span class="line">&#x2F;&#x2F; 添加对象</span><br><span class="line">mv.addObject(&quot;users&quot;, users);</span><br><span class="line">return mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC框架提供的转发和重定向"><a href="#SpringMVC框架提供的转发和重定向" class="headerlink" title="SpringMVC框架提供的转发和重定向"></a>SpringMVC框架提供的转发和重定向</h2><h3 id="forward请求转发"><a href="#forward请求转发" class="headerlink" title="forward请求转发"></a>forward请求转发</h3><p>controller方法返回String类型，想进行请求转发也可以编写成  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 使用forward关键字进行请求转发</span><br><span class="line">* &quot;forward:转发的JSP路径&quot;，不走视图解析器了，所以需要编写完整的路径</span><br><span class="line">* @return</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(&quot;&#x2F;delete&quot;)</span><br><span class="line">public String delete() throws Exception &#123;</span><br><span class="line">System.out.println(&quot;delete方法执行了...&quot;);</span><br><span class="line">&#x2F;&#x2F; return &quot;forward:&#x2F;WEB-INF&#x2F;pages&#x2F;success.jsp&quot;;</span><br><span class="line">return &quot;forward:&#x2F;user&#x2F;findAll&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redirect重定向"><a href="#redirect重定向" class="headerlink" title="redirect重定向"></a>redirect重定向</h3><p>controller方法返回String类型，想进行重定向也可以编写成  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 重定向</span><br><span class="line">* @return</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(&quot;&#x2F;count&quot;)</span><br><span class="line">public String count() throws Exception &#123;</span><br><span class="line">System.out.println(&quot;count方法执行了...&quot;);</span><br><span class="line">return &quot;redirect:&#x2F;add.jsp&quot;;</span><br><span class="line">&#x2F;&#x2F; return &quot;redirect:&#x2F;user&#x2F;findAll&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ResponseBody响应json数据"><a href="#ResponseBody响应json数据" class="headerlink" title="ResponseBody响应json数据"></a>ResponseBody响应json数据</h2><blockquote>
<p>DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而<br>不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置  </p>
<ol>
<li>mvc:resources标签配置不过滤  <ol>
<li>location元素表示webapp目录下的包下的所有文件  </li>
<li>mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b  </li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 设置静态资源不过滤 --&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;css&#x2F;&quot; mapping&#x3D;&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt; &lt;!-- 样式 --&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;images&#x2F;&quot; mapping&#x3D;&quot;&#x2F;images&#x2F;**&quot;&#x2F;&gt; &lt;!-- 图片 --&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;js&#x2F;&quot; mapping&#x3D;&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt; &lt;!-- javascript --&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用-RequestBody获取请求体数据"><a href="#使用-RequestBody获取请求体数据" class="headerlink" title="使用@RequestBody获取请求体数据"></a>使用@RequestBody获取请求体数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 页面加载</span><br><span class="line">$(function()&#123;</span><br><span class="line">&#x2F;&#x2F; 绑定点击事件</span><br><span class="line">$(&quot;#btn&quot;).click(function()&#123;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;user&#x2F;testJson&quot;,</span><br><span class="line">contentType:&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;,</span><br><span class="line">data:&#39;&#123;&quot;addressName&quot;:&quot;aa&quot;,&quot;addressNum&quot;:100&#125;&#39;,</span><br><span class="line">dataType:&quot;json&quot;,</span><br><span class="line">type:&quot;post&quot;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">alert(data);</span><br><span class="line">alert(data.addressName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 获取请求体的数据</span><br><span class="line">* @param body</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(&quot;&#x2F;testJson&quot;)</span><br><span class="line">public void testJson(@RequestBody String body) &#123;</span><br><span class="line">System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-RequestBody注解把json的字符串转换成JavaBean的对象"><a href="#使用-RequestBody注解把json的字符串转换成JavaBean的对象" class="headerlink" title="使用@RequestBody注解把json的字符串转换成JavaBean的对象"></a>使用@RequestBody注解把json的字符串转换成JavaBean的对象</h3><p>json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;</span><br><span class="line">dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;testJson&quot;)</span><br><span class="line">public void testJson(@RequestBody Address address) &#123;</span><br><span class="line">System.out.println(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-ResponseBody注解把JavaBean对象转换成json字符串，直接响应"><a href="#使用-ResponseBody注解把JavaBean对象转换成json字符串，直接响应" class="headerlink" title="使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应"></a>使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;testJson&quot;)</span><br><span class="line">public @ResponseBody Address testJson(@RequestBody Address address) &#123;</span><br><span class="line">System.out.println(address);</span><br><span class="line">address.setAddressName(&quot;上海&quot;);</span><br><span class="line">return address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SpringMVC实现文件上传"><a href="#SpringMVC实现文件上传" class="headerlink" title="SpringMVC实现文件上传"></a><center>SpringMVC实现文件上传</center></h1><h2 id="文件上传的回顾"><a href="#文件上传的回顾" class="headerlink" title="文件上传的回顾"></a>文件上传的回顾</h2><h3 id="文件上传的必要前提"><a href="#文件上传的必要前提" class="headerlink" title="文件上传的必要前提"></a>文件上传的必要前提</h3><blockquote>
<p>A form 表单的 enctype 取值必须是： multipart/form-data(默认值是:application/x-www-form-urlencoded)<br>enctype:是表单请求正文的类型<br>B method 属性取值必须是 Post<br>C 提供一个文件选择域<input type="file" />  </p>
</blockquote>
<h3 id="文件上传的原理分析"><a href="#文件上传的原理分析" class="headerlink" title="文件上传的原理分析"></a>文件上传的原理分析</h3><blockquote>
<p>当 form 表单的 enctype 取值不是默认值后， request.getParameter()将失效。<br>enctype=”application/x-www-form-urlencoded”时， form 表单的正文内容是：<br>key=value&amp;key=value&amp;key=value<br>当 form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成：<br>每一部分都是 MIME 类型描述的正文<br>—————————–7de1a433602ac 分界符<br>Content-Disposition: form-data; name=”userName” 协议头  </p>
<p>aaa 协议的正文<br>—————————–7de1a433602ac<br>Content-Disposition: form-data; name=”file”;<br>filename=”C:\Users\zhy\Desktop\fileupload_demofile\b.txt”<br>Content-Type: text/plain 协议的类型（ MIME 类型）<br>bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb<br>—————————–7de1a433602ac–  </p>
</blockquote>
<h3 id="导入文件上传的jar包"><a href="#导入文件上传的jar包" class="headerlink" title="导入文件上传的jar包"></a>导入文件上传的jar包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="编写文件上传的JSP页面"><a href="#编写文件上传的JSP页面" class="headerlink" title="编写文件上传的JSP页面"></a>编写文件上传的JSP页面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;文件上传&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;user&#x2F;fileupload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">选择文件：&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;upload&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传文件&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写文件上传的Controller控制器"><a href="#编写文件上传的Controller控制器" class="headerlink" title="编写文件上传的Controller控制器"></a>编写文件上传的Controller控制器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 文件上传</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;fileupload&quot;)</span><br><span class="line">public String fileupload(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 先获取到要上传的文件目录</span><br><span class="line">String path &#x3D; request.getSession().getServletContext().getRealPath(&quot;&#x2F;uploads&quot;);</span><br><span class="line">&#x2F;&#x2F; 创建File对象，一会向该路径下上传文件</span><br><span class="line">File file &#x3D; new File(path);</span><br><span class="line">&#x2F;&#x2F; 判断路径是否存在，如果不存在，创建该路径</span><br><span class="line">if(!file.exists()) &#123;</span><br><span class="line">file.mkdirs();</span><br><span class="line">&#125; &#x2F;</span><br><span class="line">&#x2F; 创建磁盘文件项工厂</span><br><span class="line">DiskFileItemFactory factory &#x3D; new DiskFileItemFactory();</span><br><span class="line">ServletFileUpload fileUpload &#x3D; new ServletFileUpload(factory);</span><br><span class="line">&#x2F;&#x2F; 解析request对象</span><br><span class="line">List&lt;FileItem&gt; list &#x3D; fileUpload.parseRequest(request);</span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for (FileItem fileItem : list) &#123;</span><br><span class="line">&#x2F;&#x2F; 判断文件项是普通字段，还是上传的文件</span><br><span class="line">if(fileItem.isFormField()) &#123;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F; 上传文件项</span><br><span class="line">&#x2F;&#x2F; 获取到上传文件的名称</span><br><span class="line">String filename &#x3D; fileItem.getName();</span><br><span class="line">&#x2F;&#x2F; 上传文件</span><br><span class="line">fileItem.write(new File(file, filename));</span><br><span class="line">&#x2F;&#x2F; 删除临时文件</span><br><span class="line">fileItem.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC传统方式文件上传"><a href="#SpringMVC传统方式文件上传" class="headerlink" title="SpringMVC传统方式文件上传"></a>SpringMVC传统方式文件上传</h2><p>SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的name属性名称相同。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;</span><br><span class="line">**</span><br><span class="line">* SpringMVC方式的文件上传</span><br><span class="line">* *</span><br><span class="line">@param request</span><br><span class="line">* @return</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;fileupload2&quot;)</span><br><span class="line">public String fileupload2(HttpServletRequest request,MultipartFile upload) throws</span><br><span class="line">Exception &#123;</span><br><span class="line">System.out.println(&quot;SpringMVC方式的文件上传...&quot;);</span><br><span class="line">&#x2F;&#x2F; 先获取到要上传的文件目录</span><br><span class="line">String path &#x3D; request.getSession().getServletContext().getRealPath(&quot;&#x2F;uploads&quot;);</span><br><span class="line">&#x2F;&#x2F; 创建File对象，一会向该路径下上传文件</span><br><span class="line">File file &#x3D; new File(path);</span><br><span class="line">&#x2F;&#x2F; 判断路径是否存在，如果不存在，创建该路径</span><br><span class="line">if(!file.exists()) &#123;</span><br><span class="line">file.mkdirs();</span><br><span class="line">&#125; &#x2F;</span><br><span class="line">&#x2F; 获取到上传文件的名称</span><br><span class="line">String filename &#x3D; upload.getOriginalFilename();</span><br><span class="line">String uuid &#x3D; UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).toUpperCase();</span><br><span class="line">&#x2F;&#x2F; 把文件的名称唯一化</span><br><span class="line">filename &#x3D; uuid+&quot;_&quot;+filename;</span><br><span class="line">&#x2F;&#x2F; 上传文件</span><br><span class="line">upload.transferTo(new File(file,filename));</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件解析器对象"><a href="#配置文件解析器对象" class="headerlink" title="配置文件解析器对象"></a>配置文件解析器对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置文件解析器对象，要求id名称必须是multipartResolver --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;multipartResolver&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;10485760&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC跨服务器方式文件上传"><a href="#SpringMVC跨服务器方式文件上传" class="headerlink" title="SpringMVC跨服务器方式文件上传"></a>SpringMVC跨服务器方式文件上传</h2><h3 id="分服务器的目的"><a href="#分服务器的目的" class="headerlink" title="分服务器的目的"></a>分服务器的目的</h3><blockquote>
<p>在实际开发中，我们会有很多处理不同功能的服务器。例如：<br>应用服务器：负责部署我们的应用<br>数据库服务器：运行我们的数据库<br>缓存和消息服务器：负责处理大并发访问的缓存和消息<br>文件服务器：负责存储用户上传文件的服务器。<br><strong>(注意：此处说的不是服务器集群）</strong>  </p>
</blockquote>
<h3 id="准备两个-tomcat-服务器，并创建一个用于存放图片的-web-工程"><a href="#准备两个-tomcat-服务器，并创建一个用于存放图片的-web-工程" class="headerlink" title="准备两个 tomcat 服务器，并创建一个用于存放图片的 web 工程"></a>准备两个 tomcat 服务器，并创建一个用于存放图片的 web 工程</h3><h3 id="导入开发需要的jar包"><a href="#导入开发需要的jar包" class="headerlink" title="导入开发需要的jar包"></a>导入开发需要的jar包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.sun.jersey&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jersey-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.sun.jersey&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jersey-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写文件上传的JSP页面-1"><a href="#编写文件上传的JSP页面-1" class="headerlink" title="编写文件上传的JSP页面"></a>编写文件上传的JSP页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;跨服务器的文件上传&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;user&#x2F;fileupload3&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">选择文件：&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;upload&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传文件&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写控制器"><a href="#编写控制器" class="headerlink" title="编写控制器"></a>编写控制器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* SpringMVC跨服务器方式的文件上传</span><br><span class="line">* *</span><br><span class="line">@param request</span><br><span class="line">* @return</span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;fileupload3&quot;)</span><br><span class="line">public String fileupload3(MultipartFile upload) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;SpringMVC跨服务器方式的文件上传...&quot;);</span><br><span class="line">&#x2F;&#x2F; 定义图片服务器的请求路径</span><br><span class="line">String path &#x3D; &quot;http:&#x2F;&#x2F;localhost:9090&#x2F;day02_springmvc5_02image&#x2F;uploads&#x2F;&quot;;</span><br><span class="line">&#x2F;&#x2F; 获取到上传文件的名称</span><br><span class="line">String filename &#x3D; upload.getOriginalFilename();</span><br><span class="line">String uuid &#x3D; UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).toUpperCase();</span><br><span class="line">&#x2F;&#x2F; 把文件的名称唯一化</span><br><span class="line">filename &#x3D; uuid+&quot;_&quot;+filename;</span><br><span class="line">&#x2F;&#x2F; 向图片服务器上传文件</span><br><span class="line">&#x2F;&#x2F; 创建客户端对象</span><br><span class="line">Client client &#x3D; Client.create();</span><br><span class="line">&#x2F;&#x2F; 连接图片服务器</span><br><span class="line">WebResource webResource &#x3D; client.resource(path+filename);</span><br><span class="line">&#x2F;&#x2F; 上传文件</span><br><span class="line">webResource.put(upload.getBytes());</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SpringMVC的异常处理"><a href="#SpringMVC的异常处理" class="headerlink" title="SpringMVC的异常处理 "></a><center>SpringMVC的异常处理 </center></h1><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><p>Controller调用service，service调用dao，异常都是向上抛出的，最终有DispatcherServlet找异常处理器进行异常的处理。  </p>
<h2 id="SpringMVC的异常处理-1"><a href="#SpringMVC的异常处理-1" class="headerlink" title="SpringMVC的异常处理"></a>SpringMVC的异常处理</h2><p>自定义异常类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SysException extends Exception&#123;</span><br><span class="line">private static final long serialVersionUID &#x3D; 4055945147128016300L;</span><br><span class="line">&#x2F;&#x2F; 异常提示信息</span><br><span class="line">private String message;</span><br><span class="line">public String getMessage() &#123;</span><br><span class="line">return message;</span><br><span class="line">&#125; p</span><br><span class="line">ublic void setMessage(String message) &#123;</span><br><span class="line">this.message &#x3D; message;</span><br><span class="line">&#125; p</span><br><span class="line">ublic SysException(String message) &#123;</span><br><span class="line">this.message &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义异常处理器  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 异常处理器</span><br><span class="line">* @author rt</span><br><span class="line">*&#x2F;</span><br><span class="line">public class SysExceptionResolver implements HandlerExceptionResolver&#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 跳转到具体的错误页面的方法</span><br><span class="line">*&#x2F;</span><br><span class="line">public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse</span><br><span class="line">response, Object handler,Exception ex) &#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">SysException e &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 获取到异常对象</span><br><span class="line">if(ex instanceof SysException) &#123;</span><br><span class="line">e &#x3D; (SysException) ex;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">e &#x3D; new SysException(&quot;请联系管理员&quot;);</span><br><span class="line">&#125; M</span><br><span class="line">odelAndView mv &#x3D; new ModelAndView();</span><br><span class="line">&#x2F;&#x2F; 存入错误的提示信息</span><br><span class="line">mv.addObject(&quot;message&quot;, e.getMessage());</span><br><span class="line">&#x2F;&#x2F; 跳转的Jsp页面</span><br><span class="line">mv.setViewName(&quot;error&quot;);</span><br><span class="line">return mv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置异常处理器  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;</span><br><span class="line">!-- 配置异常处理器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sysExceptionResolver&quot; class&#x3D;&quot;cn.syx.exception.SysExceptionResolver&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="SpringMVC-中的拦截器"><a href="#SpringMVC-中的拦截器" class="headerlink" title="SpringMVC 中的拦截器"></a><center>SpringMVC 中的拦截器</center></h1><h2 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h2><blockquote>
<p>Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。<br>用户可以自己定义一些拦截器来实现特定的功能。<br>谈到拦截器，就要提一个词——拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。</p>
<p>过滤器和拦截器区别：</p>
<p>过滤器是 servlet 规范中的一部分， 任何 java web 工程都可以使用。<br>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。<br>过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。<br>拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp， html,css,image 或者 js 是不会进行拦截的。<br>它也是 AOP 思想的具体应用。<br>我们要想自定义拦截器， 要求必须实现： HandlerInterceptor 接口。    </p>
</blockquote>
<h2 id="自定义拦截器的步骤"><a href="#自定义拦截器的步骤" class="headerlink" title="自定义拦截器的步骤"></a>自定义拦截器的步骤</h2><h3 id="第一步：编写一个普通类实现-HandlerInterceptor-接口"><a href="#第一步：编写一个普通类实现-HandlerInterceptor-接口" class="headerlink" title="第一步：编写一个普通类实现 HandlerInterceptor 接口"></a>第一步：编写一个普通类实现 HandlerInterceptor 接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 自定义拦截器1</span><br><span class="line">* @author rt</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MyInterceptor1 implements HandlerInterceptor&#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* controller方法执行前，进行拦截的方法</span><br><span class="line">* return true放行</span><br><span class="line">* return false拦截</span><br><span class="line">* 可以使用转发或者重定向直接跳转到指定的页面。</span><br><span class="line">*&#x2F;</span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler)throws Exception &#123;</span><br><span class="line">System.out.println(&quot;拦截器执行了...&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：配置拦截器"><a href="#第二步：配置拦截器" class="headerlink" title="第二步：配置拦截器"></a>第二步：配置拦截器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">&lt;mvc:interceptor&gt;</span><br><span class="line">&lt;!-- 哪些方法进行拦截 --&gt;</span><br><span class="line">&lt;mvc:mapping path&#x3D;&quot;&#x2F;user&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 哪些方法不进行拦截</span><br><span class="line">&lt;mvc:exclude-mapping path&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- 注册拦截器对象 --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;cn.itcast.demo1.MyInterceptor1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<h2 id="HandlerInterceptor接口中的方法"><a href="#HandlerInterceptor接口中的方法" class="headerlink" title="HandlerInterceptor接口中的方法"></a>HandlerInterceptor接口中的方法</h2><p>preHandle方法是controller方法执行前拦截的方法  </p>
<blockquote>
<p>可以使用request或者response跳转到指定的页面<br>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。<br>return false不放行，不会执行controller中的方法。  </p>
</blockquote>
<p>postHandle是controller方法执行后执行的方法，在JSP视图执行前。  </p>
<blockquote>
<p>可以使用request或者response跳转到指定的页面<br>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。  </p>
</blockquote>
<p>postHandle方法是在JSP执行后执行  </p>
<blockquote>
<p>request或者response不能再跳转页面了  </p>
</blockquote>
]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAoc</title>
    <url>/2020/04/05/SpringAoc/</url>
    <content><![CDATA[<h1 id="AOP-的相关概念"><a href="#AOP-的相关概念" class="headerlink" title="AOP 的相关概念  "></a><center>AOP 的相关概念  </center></h1><h2 id="AOP-概述"><a href="#AOP-概述" class="headerlink" title="AOP 概述"></a>AOP 概述</h2><h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><blockquote>
<p>AOP： 全称是 Aspect Oriented Programming 即： 面向切面编程。 </p>
<p><img src="/" class="lazyload" data-src="/img/Spring/2.png"  alt=""></p>
<p>简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。  </p>
</blockquote>
<h3 id="AOP-的作用及优势"><a href="#AOP-的作用及优势" class="headerlink" title="AOP 的作用及优势"></a>AOP 的作用及优势</h3><blockquote>
<p><strong>作用</strong>：</p>
<ul>
<li>在程序运行期间，不修改源码对已有方法进行增强。</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>减少重复代码</li>
<li>提高开发效率</li>
<li>维护方便  </li>
</ul>
</blockquote>
<h3 id="AOP-的实现方式"><a href="#AOP-的实现方式" class="headerlink" title="AOP 的实现方式"></a>AOP 的实现方式</h3><blockquote>
<p>使用动态代理技术  </p>
</blockquote>
<h2 id="动态代理回顾"><a href="#动态代理回顾" class="headerlink" title="动态代理回顾"></a>动态代理回顾</h2><h3 id="动态代理的特点"><a href="#动态代理的特点" class="headerlink" title="动态代理的特点"></a>动态代理的特点</h3><blockquote>
<p>字节码随用随创建，随用随加载。<br>它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。<br>装饰者模式就是静态代理的一种体现。  </p>
</blockquote>
<h3 id="动态代理常用的有两种方式"><a href="#动态代理常用的有两种方式" class="headerlink" title="动态代理常用的有两种方式"></a>动态代理常用的有两种方式</h3><blockquote>
<p>*<em>基于接口的动态代理 *</em></p>
<p>提供者： JDK 官方的 Proxy 类。<br>要求：被代理类最少实现一个接口。<br><strong>基于子类的动态代理</strong><br>提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。<br>要求：被代理类不能用 final 修饰的类（最终类）。   </p>
</blockquote>
<h3 id="使用-JDK-官方的-Proxy-类创建代理对象"><a href="#使用-JDK-官方的-Proxy-类创建代理对象" class="headerlink" title="使用 JDK 官方的 Proxy 类创建代理对象"></a>使用 JDK 官方的 Proxy 类创建代理对象</h3><p>此处我们使用的是一个演员的例子：<br>在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪人来找了。下面我们就用代码演示出来。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 一个经纪公司的要求:</span><br><span class="line">* 能做基本的表演和危险的表演</span><br><span class="line">*&#x2F;</span><br><span class="line">public interface IActor &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 基本演出</span><br><span class="line">* @param money</span><br><span class="line">*&#x2F;</span><br><span class="line">public void basicAct(float money);</span><br><span class="line">&#x2F;**</span><br><span class="line">* 危险演出</span><br><span class="line">* @param money</span><br><span class="line">*&#x2F;</span><br><span class="line">public void dangerAct(float money);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 一个演员</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求</span><br><span class="line">public class Actor implements IActor&#123;</span><br><span class="line">public void basicAct(float money)&#123;</span><br><span class="line">System.out.println(&quot;拿到钱，开始基本的表演： &quot;+money);</span><br><span class="line">&#125;</span><br><span class="line">public void dangerAct(float money)&#123;</span><br><span class="line">System.out.println(&quot;拿到钱，开始危险的表演： &quot;+money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;一个剧组找演员：</span><br><span class="line">final Actor actor &#x3D; new Actor();&#x2F;&#x2F;直接</span><br><span class="line">&#x2F;**</span><br><span class="line">* 代理：</span><br><span class="line">* 间接。</span><br><span class="line">* 获取代理对象：</span><br><span class="line">* 要求：</span><br><span class="line">* 被代理类最少实现一个接口</span><br><span class="line">* 创建的方式</span><br><span class="line">* Proxy.newProxyInstance(三个参数)</span><br><span class="line">* 参数含义：</span><br><span class="line">* ClassLoader：和被代理对象使用相同的类加载器。</span><br><span class="line">* Interfaces：和被代理对象具有相同的行为。实现相同的接口。</span><br><span class="line">* InvocationHandler：如何代理。</span><br><span class="line">* 策略模式：使用场景是：</span><br><span class="line">* 数据有了，目的明确。</span><br><span class="line">* 如何达成目标，就是策略。</span><br><span class="line">*&#x2F;</span><br><span class="line">IActor proxyActor &#x3D; (IActor) Proxy.newProxyInstance(</span><br><span class="line">actor.getClass().getClassLoader(),</span><br><span class="line">actor.getClass().getInterfaces(),</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 执行被代理对象的任何方法，都会经过该方法。</span><br><span class="line">* 此方法有拦截的功能。</span><br><span class="line">* 参数：</span><br><span class="line">* proxy：代理对象的引用。不一定每次都用得到</span><br><span class="line">* method：当前执行的方法对象</span><br><span class="line">* args：执行方法所需的参数</span><br><span class="line">* 返回值：</span><br><span class="line">* 当前执行方法的返回值</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">throws Throwable &#123;</span><br><span class="line">String name &#x3D; method.getName();</span><br><span class="line">Float money &#x3D; (Float) args[0];</span><br><span class="line">Object rtValue &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;每个经纪公司对不同演出收费不一样，此处开始判断</span><br><span class="line">if(&quot;basicAct&quot;.equals(name))&#123;</span><br><span class="line">&#x2F;&#x2F;基本演出，没有 2000 不演</span><br><span class="line">if(money &gt; 2000)&#123;</span><br><span class="line">&#x2F;&#x2F;看上去剧组是给了 8000，实际到演员手里只有 4000</span><br><span class="line">&#x2F;&#x2F;这就是我们没有修改原来 basicAct 方法源码，对方法进行了增强</span><br><span class="line">rtValue &#x3D; method.invoke(actor, money&#x2F;2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(&quot;dangerAct&quot;.equals(name))&#123;</span><br><span class="line">&#x2F;&#x2F;危险演出,没有 5000 不演</span><br><span class="line">if(money &gt; 5000)&#123;</span><br><span class="line">&#x2F;&#x2F;看上去剧组是给了 50000，实际到演员手里只有 25000</span><br><span class="line">&#x2F;&#x2F;这就是我们没有修改原来 dangerAct 方法源码，对方法进行了增强</span><br><span class="line">rtValue &#x3D; method.invoke(actor, money&#x2F;2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return rtValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;没有经纪公司的时候，直接找演员。</span><br><span class="line">&#x2F;&#x2F; actor.basicAct(1000f);</span><br><span class="line">&#x2F;&#x2F; actor.dangerAct(5000f);</span><br><span class="line">&#x2F;&#x2F;剧组无法直接联系演员，而是由经纪公司找的演员</span><br><span class="line">proxyActor.basicAct(8000f);</span><br><span class="line">proxyActor.dangerAct(50000f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-CGLib-的-Enhancer-类创建代理对象"><a href="#使用-CGLib-的-Enhancer-类创建代理对象" class="headerlink" title="使用 CGLib 的 Enhancer 类创建代理对象"></a>使用 CGLib 的 Enhancer 类创建代理对象</h3><p>还是那个演员的例子，只不过不让他实现接口。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 一个演员</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Actor&#123;&#x2F;&#x2F;没有实现任何接口</span><br><span class="line">public void basicAct(float money)&#123;</span><br><span class="line">System.out.println(&quot;拿到钱，开始基本的表演： &quot;+money);</span><br><span class="line">&#125;</span><br><span class="line">public void dangerAct(float money)&#123;</span><br><span class="line">System.out.println(&quot;拿到钱，开始危险的表演： &quot;+money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 基于子类的动态代理</span><br><span class="line">* 要求：</span><br><span class="line">* 被代理对象不能是最终类</span><br><span class="line">* 用到的类：</span><br><span class="line">* Enhancer</span><br><span class="line">* 用到的方法：</span><br><span class="line">* create(Class, Callback)</span><br><span class="line">* 方法的参数：</span><br><span class="line">* Class：被代理对象的字节码</span><br><span class="line">* Callback：如何代理</span><br><span class="line">* @param args</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">final Actor actor &#x3D; new Actor();</span><br><span class="line">Actor cglibActor &#x3D; (Actor) Enhancer.create(actor.getClass(),</span><br><span class="line">new MethodInterceptor() &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何</span><br><span class="line">方法进行增强。</span><br><span class="line">*</span><br><span class="line">* 参数：</span><br><span class="line">* 前三个和基于接口的动态代理是一样的。</span><br><span class="line">* MethodProxy：当前执行方法的代理对象。</span><br><span class="line">* 返回值：</span><br><span class="line">* 当前执行方法的返回值</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object proxy, Method method, Object[] args,</span><br><span class="line">MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">String name &#x3D; method.getName();</span><br><span class="line">Float money &#x3D; (Float) args[0];</span><br><span class="line">Object rtValue &#x3D; null;</span><br><span class="line">if(&quot;basicAct&quot;.equals(name))&#123;</span><br><span class="line">&#x2F;&#x2F;基本演出</span><br><span class="line">if(money &gt; 2000)&#123;</span><br><span class="line">rtValue &#x3D; method.invoke(actor, money&#x2F;2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(&quot;dangerAct&quot;.equals(name))&#123;</span><br><span class="line">&#x2F;&#x2F;危险演出</span><br><span class="line">if(money &gt; 5000)&#123;</span><br><span class="line">rtValue &#x3D; method.invoke(actor, money&#x2F;2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return rtValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">cglibActor.basicAct(10000);</span><br><span class="line">cglibActor.dangerAct(100000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-中的-AOP"><a href="#Spring-中的-AOP" class="headerlink" title="Spring 中的 AOP"></a><center>Spring 中的 AOP</center></h1><h2 id="Spring-中-AOP-的细节"><a href="#Spring-中-AOP-的细节" class="headerlink" title="Spring 中 AOP 的细节"></a>Spring 中 AOP 的细节</h2><h3 id="AOP-相关术语"><a href="#AOP-相关术语" class="headerlink" title="AOP 相关术语"></a>AOP 相关术语</h3><blockquote>
<p><strong>Joinpoint(连接点):</strong><br>所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的<br>连接点。<br><strong>Pointcut(切入点):</strong><br>所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。  </p>
<p><strong>Advice(通知/增强):</strong><br>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。<br>通知的类型： 前置通知,后置通知,异常通知,最终通知,环绕通知。<br><strong>Introduction(引介):</strong><br>引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方<br>法或 Field。<br><strong>Target(目标对象):</strong><br>代理的目标对象。<br><strong>Weaving(织入):</strong><br>是指把增强应用到目标对象来创建新的代理对象的过程。<br>spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。<br><strong>Proxy（代理） :</strong><br>一个类被 AOP 织入增强后，就产生一个结果代理类。<br><strong>Aspect(切面):</strong><br>是切入点和通知（引介）的结合。  </p>
</blockquote>
<h3 id="spring-中的-AOP-要明确的事"><a href="#spring-中的-AOP-要明确的事" class="headerlink" title="spring 中的 AOP 要明确的事"></a>spring 中的 AOP 要明确的事</h3><blockquote>
<p><strong>a、开发阶段（我们做的）</strong><br>编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。<br>把公用代码抽取出来，制作成通知。（开发阶段最后再做）： AOP 编程人员来做。<br>在配置文件中，声明切入点与通知间的关系，即切面。： AOP 编程人员来做。<br><strong>b、运行阶段（ Spring 框架完成的）</strong><br>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对<br>象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。  </p>
</blockquote>
<h3 id="关于代理的选择"><a href="#关于代理的选择" class="headerlink" title="关于代理的选择"></a>关于代理的选择</h3><blockquote>
<p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。  </p>
</blockquote>
<h1 id="基于-XML-的-AOP-配置"><a href="#基于-XML-的-AOP-配置" class="headerlink" title="基于 XML 的 AOP 配置"></a><center>基于 XML 的 AOP 配置</center></h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="第一步：导入依赖"><a href="#第一步：导入依赖" class="headerlink" title="第一步：导入依赖"></a>第一步：导入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.8.13&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-dbutils&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-dbutils&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：创建-spring-的配置文件并导入约束"><a href="#第二步：创建-spring-的配置文件并导入约束" class="headerlink" title="第二步：创建 spring 的配置文件并导入约束"></a>第二步：创建 spring 的配置文件并导入约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--此处要导入 aop 的约束--&gt;</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：-配置-spring-的-ioc"><a href="#第三步：-配置-spring-的-ioc" class="headerlink" title="第三步： 配置 spring 的 ioc"></a>第三步： 配置 spring 的 ioc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置 service --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDao&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">  &lt;!--配置Dao对象--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountDao&quot; class&#x3D;&quot;com.syx.dao.impl.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;!-- 注入QueryRunner --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;runner&quot; ref&#x3D;&quot;runner&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!-- 注入ConnectionUtils --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connectionUtils&quot; ref&#x3D;&quot;connectionUtils&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">     &lt;!--配置QueryRunner--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;runner&quot; class&#x3D;&quot;org.apache.commons.dbutils.QueryRunner&quot; scope&#x3D;&quot;prototype&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;!--连接数据库的必备信息--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置Connection的工具类 ConnectionUtils --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;connectionUtils&quot; class&#x3D;&quot;com.itheima.utils.ConnectionUtils&quot;&gt;</span><br><span class="line">        &lt;!-- 注入数据源--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：-抽取公共代码制作成通知"><a href="#第四步：-抽取公共代码制作成通知" class="headerlink" title="第四步： 抽取公共代码制作成通知"></a>第四步： 抽取公共代码制作成通知</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransactionManager &#123;</span><br><span class="line">    private ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    public void setConnectionUtils(ConnectionUtils connectionUtils) &#123;</span><br><span class="line">        this.connectionUtils &#x3D; connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 开启事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void beginTransaction() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(false);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void commit() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 回滚事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void rollback() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().rollback();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放连接</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void release() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().close();&#x2F;&#x2F;还回连接池中</span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConnectionUtils &#123;</span><br><span class="line"></span><br><span class="line">    private ThreadLocal&lt;Connection&gt; tl &#x3D; new ThreadLocal&lt;Connection&gt;();</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.dataSource &#x3D; dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前线程上的连接</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Connection getThreadConnection() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            &#x2F;&#x2F;1.先从ThreadLocal上获取</span><br><span class="line">            Connection conn &#x3D; tl.get();</span><br><span class="line">            &#x2F;&#x2F;2.判断当前线程上是否有连接</span><br><span class="line">            if (conn &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;3.从数据源中获取一个连接，并且存入ThreadLocal中</span><br><span class="line">                conn &#x3D; dataSource.getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;4.返回当前线程上的连接</span><br><span class="line">            return conn;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把连接和线程解绑</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void removeConnection()&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="第一步：把通知类用-bean-标签配置起来"><a href="#第一步：把通知类用-bean-标签配置起来" class="headerlink" title="第一步：把通知类用 bean 标签配置起来"></a>第一步：把通知类用 bean 标签配置起来</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;com.itheima.utils.TransactionManager&quot;&gt;</span><br><span class="line">    &lt;!-- 注入ConnectionUtils --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionUtils&quot; ref&#x3D;&quot;connectionUtils&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：使用 aop:config 声明 aop 配置  </p>
<blockquote>
<p>aop:config:<br><strong>作用</strong>： 用于声明开始 aop 的配置  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;!-- 配置的代码都写在此处 --&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<p>第三步：使用 aop:aspect 配置切面  </p>
<blockquote>
<p>aop:aspect:<br><strong>作用</strong>：<br>用于配置切面。<br><strong>属性</strong>：<br>id： 给切面提供一个唯一标识。<br>ref： 引用配置好的通知类 bean 的 id。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspect id&#x3D;&quot;txAdvice&quot; ref&#x3D;&quot;txManager&quot;&gt;</span><br><span class="line">&lt;!--配置通知的类型要写在此处--&gt;</span><br><span class="line">&lt;&#x2F;aop:aspect&gt;</span><br></pre></td></tr></table></figure>

<p>第四步：使用 aop:pointcut 配置切入点表达式  </p>
<blockquote>
<p>aop:pointcut：<br><strong>作用</strong>：<br>用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。<br><strong>属性</strong>：<br>expression：用于定义切入点表达式。<br>id： 用于给切入点表达式提供一个唯一标识  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:pointcut expression&#x3D;&quot;execution(</span><br><span class="line">public void com.syx.service.impl.AccountServiceImpl.transfer(</span><br><span class="line">java.lang.String, java.lang.String, java.lang.Float)</span><br><span class="line">)&quot; id&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>第五步：使用 aop:xxx 配置对应的通知类型  </p>
<blockquote>
<p>1.aop:before<br><strong>作用</strong>：<br>用于配置前置通知。 指定增强的方法在切入点方法之前执行<br><strong>属性</strong>：<br>method:用于指定通知类中的增强方法名称<br>ponitcut-ref：用于指定切入点的表达式的引用<br>poinitcut：用于指定切入点表达式<br><strong>执行时间点</strong>：<br>切入点方法执行之前执行  </p>
<p>2.aop:after-returning  </p>
<p><strong>作用</strong>：<br>用于配置后置通知<br><strong>属性</strong>：<br>method： 指定通知中方法的名称。<br>pointct： 定义切入点表达式<br>pointcut-ref： 指定切入点表达式的引用<br><strong>执行时间点</strong>：<br>切入点方法正常执行之后。它和异常通知只能有一个执行  </p>
<p>3.aop:after-throwing<br><strong>作用</strong>：<br>用于配置异常通知<br><strong>属性</strong>：<br>method： 指定通知中方法的名称。<br>pointct： 定义切入点表达式<br>pointcut-ref： 指定切入点表达式的引用<br><strong>执行时间点</strong>：<br>切入点方法执行产生异常后执行。它和后置通知只能执行一个  </p>
<p>4.aop:after<br><strong>作用</strong>：<br>用于配置最终通知<br><strong>属性</strong>：<br>method： 指定通知中方法的名称。<br>pointct： 定义切入点表达式<br>pointcut-ref： 指定切入点表达式的引用<br><strong>执行时间点</strong>：<br>无论切入点方法执行时是否有异常，它都会在其后面执行。  </p>
</blockquote>
<p><strong>xml配置：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:before method&#x3D;&quot;beginTransaction&quot; pointcut-ref&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">&lt;aop:after-returning method&#x3D;&quot;commit&quot; pointcut-ref&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">&lt;aop:after-throwing method&#x3D;&quot;rollback&quot; pointcut-ref&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">&lt;aop:after method&#x3D;&quot;release&quot; pointcut-ref&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="切入点表达式说明"><a href="#切入点表达式说明" class="headerlink" title="切入点表达式说明"></a>切入点表达式说明</h3><blockquote>
<p>execution:匹配方法的执行(常用)<br>execution(表达式)<br>表达式语法： execution([修饰符] 返回值类型 包名.类名.方法名(参数))<br>写法说明：<br>全匹配方式：<br>public void com.syx.service.impl.AccountServiceImpl.saveAccount(com.syx.domain.Account)<br>访问修饰符可以省略<br>void<br>com.syx.service.impl.AccountServiceImpl.saveAccount(com.syx.domain.Account)  </p>
<p>返回值可以使用*号，表示任意返回值</p>
<p>*com.syx.service.impl.AccountServiceImpl.saveAccount(com.syx.domain.Account)<br>包名可以使用<em>号，表示任意包，但是有几级包，需要写几个</em><br>* <em>.</em>.<em>.</em>.AccountServiceImpl.saveAccount(com.syx.domain.Account)<br>使用..来表示当前包，及其子包<br>* com..AccountServiceImpl.saveAccount(com.syx.domain.Account)<br>类名可以使用<em>号，表示任意类<br>\</em> com..<em>.saveAccount(com.syx.domain.Account)<br>方法名可以使用*号，表示任意方法<br>\</em> com..<em>.</em>( com.syx.domain.Account)<br>参数列表可以使用<em>，表示参数可以是任意数据类型，但是必须有参数<br>\</em> com..<em>.</em>(<em>)<br>参数列表可以使用..表示有无参数均可，有参数可以是任意类型<br>\</em> com..<em>.</em>(..)<br>全通配方式：<br>* <em>..</em>.<em>(..)<br>注：<br>通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。<br>execution(</em> com.syx.service.impl.<em>.</em>(..))  </p>
</blockquote>
<h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置方式:--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:pointcut expression&#x3D;&quot;execution(* com.syx.service.impl.*.*(..))&quot;</span><br><span class="line">id&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">&lt;aop:aspect id&#x3D;&quot;txAdvice&quot; ref&#x3D;&quot;txManager&quot;&gt;</span><br><span class="line">&lt;!-- 配置环绕通知 --&gt;</span><br><span class="line">&lt;aop:around method&#x3D;&quot;transactionAround&quot; pointcut-ref&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:aspect&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>aop:around：<br><strong>作用</strong>：<br>用于配置环绕通知<br><strong>属性</strong>：<br>method：指定通知中方法的名称。<br>pointct：定义切入点表达式<br>pointcut-ref：指定切入点表达式的引用<br><strong>说明</strong>：<br>它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。<br>注意：<br>通常情况下，环绕通知都是独立使用的  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 环绕通知</span><br><span class="line">* @param pjp</span><br><span class="line">* spring 框架为我们提供了一个接口： ProceedingJoinPoint，它可以作为环绕通知的方法参数。</span><br><span class="line">* 在环绕通知执行时， spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">public Object transactionAround(ProceedingJoinPoint pjp) &#123;</span><br><span class="line">&#x2F;&#x2F;定义返回值</span><br><span class="line">Object rtValue &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;获取方法执行所需的参数</span><br><span class="line">Object[] args &#x3D; pjp.getArgs();</span><br><span class="line">&#x2F;&#x2F;前置通知：开启事务</span><br><span class="line">beginTransaction();</span><br><span class="line">&#x2F;&#x2F;执行方法</span><br><span class="line">rtValue &#x3D; pjp.proceed(args);</span><br><span class="line">&#x2F;&#x2F;后置通知：提交事务</span><br><span class="line">commit();</span><br><span class="line">&#125;catch(Throwable e) &#123;</span><br><span class="line">&#x2F;&#x2F;异常通知：回滚事务</span><br><span class="line">rollback();</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">&#x2F;&#x2F;最终通知：释放资源</span><br><span class="line">release();</span><br><span class="line">&#125;</span><br><span class="line">return rtValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于注解的-AOP-配置"><a href="#基于注解的-AOP-配置" class="headerlink" title="基于注解的 AOP 配置 "></a><center>基于注解的 AOP 配置 </center></h1><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="第一步：-准备必要的代码和-jar-包"><a href="#第一步：-准备必要的代码和-jar-包" class="headerlink" title="第一步： 准备必要的代码和 jar 包"></a>第一步： 准备必要的代码和 jar 包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.8.13&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-dbutils&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-dbutils&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：-在配置文件中导入-context-的名称空间"><a href="#第二步：-在配置文件中导入-context-的名称空间" class="headerlink" title="第二步： 在配置文件中导入 context 的名称空间"></a>第二步： 在配置文件中导入 context 的名称空间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 告知 spring 创建容器时要扫描的包 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.syx&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置QueryRunner--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;runner&quot; class&#x3D;&quot;org.apache.commons.dbutils.QueryRunner&quot; scope&#x3D;&quot;prototype&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;!--连接数据库的必备信息--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：把资源使用注解配置"><a href="#第三步：把资源使用注解配置" class="headerlink" title="第三步：把资源使用注解配置"></a>第三步：把资源使用注解配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository(&quot;accountDao&quot;)</span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private QueryRunner runner;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConnectionUtils connectionUtils;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">@Service(&quot;accountService&quot;)</span><br><span class="line">public class AccountServiceImpl implements IAccountService&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IAccountDao accountDao;</span><br></pre></td></tr></table></figure>

<h2 id="配置步骤-1"><a href="#配置步骤-1" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="第一步：把通知类也使用注解配置"><a href="#第一步：把通知类也使用注解配置" class="headerlink" title="第一步：把通知类也使用注解配置"></a>第一步：把通知类也使用注解配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component(&quot;txManager&quot;)</span><br><span class="line">public class TransactionManager &#123;</span><br><span class="line">&#x2F;&#x2F;定义一个 DBAssit</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConnectionUtils connectionUtils;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：在通知类上使用-Aspect-注解声明为切面"><a href="#第二步：在通知类上使用-Aspect-注解声明为切面" class="headerlink" title="第二步：在通知类上使用@Aspect 注解声明为切面"></a>第二步：在通知类上使用@Aspect 注解声明为切面</h3><blockquote>
<p>作用：<br>把当前类声明为切面类。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component(&quot;txManager&quot;)</span><br><span class="line">@Aspect</span><br><span class="line">public class TransactionManager &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConnectionUtils connectionUtils;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：在增强的方法上使用注解配置通知"><a href="#第三步：在增强的方法上使用注解配置通知" class="headerlink" title="第三步：在增强的方法上使用注解配置通知"></a>第三步：在增强的方法上使用注解配置通知</h3><blockquote>
<p>@Before<br>作用：<br>把当前方法看成是前置通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用。  </p>
<p>@AfterReturning<br>作用：<br>把当前方法看成是后置通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用  </p>
<p>@AfterThrowing<br>作用：<br>把当前方法看成是异常通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用  </p>
<p>@After<br>作用：<br>把当前方法看成是最终通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 开启事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">     @Before(&quot;execution(* com.syx.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void beginTransaction() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(false);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">     @AfterReturning(&quot;execution(* com.syx.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void commit() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 回滚事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">     @AfterThrowing(&quot;execution(* com.syx.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void rollback() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().rollback();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放连接</span><br><span class="line">     *&#x2F;</span><br><span class="line">     @After(&quot;execution(* com.syx.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void release() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().close();&#x2F;&#x2F;还回连接池中</span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：在-spring-配置文件中开启-spring-对注解-AOP-的支持"><a href="#第四步：在-spring-配置文件中开启-spring-对注解-AOP-的支持" class="headerlink" title="第四步：在 spring 配置文件中开启 spring 对注解 AOP 的支持"></a>第四步：在 spring 配置文件中开启 spring 对注解 AOP 的支持</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="环绕通知注解配置"><a href="#环绕通知注解配置" class="headerlink" title="环绕通知注解配置"></a>环绕通知注解配置</h3><blockquote>
<p>@Around<br>作用：<br>把当前方法看成是环绕通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   @Pointcut(&quot;execution(* com.syx.service.impl.*.*(..))&quot;)</span><br><span class="line">   private void pt1() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    * 环绕通知</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Around(&quot;pt1()&quot;)</span><br><span class="line">   public Object aroundAdvice(ProceedingJoinPoint pjp) &#123;</span><br><span class="line">      Object reValue &#x3D; null;</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F;1.获取参数</span><br><span class="line">           Object[] args &#x3D; pjp.getArgs();</span><br><span class="line">           &#x2F;&#x2F;2.开启事务</span><br><span class="line">           this.beginTransaction();</span><br><span class="line">           &#x2F;&#x2F;3.执行方法</span><br><span class="line">           reValue &#x3D; pjp.proceed(args);</span><br><span class="line">           &#x2F;&#x2F;4.提交事务</span><br><span class="line">           this.commit();</span><br><span class="line">           return reValue;</span><br><span class="line">       &#125; catch (Throwable e) &#123;</span><br><span class="line">           &#x2F;&#x2F;5.回滚事务</span><br><span class="line">           this.rollback();</span><br><span class="line">           throw new RuntimeException(e);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           &#x2F;&#x2F;6.释放资源</span><br><span class="line">           this.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="切入点表达式注解"><a href="#切入点表达式注解" class="headerlink" title="切入点表达式注解"></a>切入点表达式注解</h3><blockquote>
<p>@Pointcut<br>作用：<br>指定切入点表达式<br>属性：  value：指定表达式的内容  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Pointcut(&quot;execution(* com.syx.service.impl.*.*(..))&quot;)</span><br><span class="line">    private void pt1() &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F;引用方式：</span><br><span class="line">&#x2F;**</span><br><span class="line">* 环绕通知</span><br><span class="line">* @param pjp</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Around(&quot;pt1()&quot;)&#x2F;&#x2F;注意：千万别忘了写括号</span><br><span class="line">public Object transactionAround(ProceedingJoinPoint pjp) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不使用-XML-的配置方式"><a href="#不使用-XML-的配置方式" class="headerlink" title="不使用 XML 的配置方式"></a>不使用 XML 的配置方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages&#x3D;&quot;com.itheima&quot;)</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringIoc（基于注解配置）</title>
    <url>/2020/04/04/SpringIoc%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建  "></a><center>环境搭建  </center></h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;5.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建并编写配置文件"><a href="#创建并编写配置文件" class="headerlink" title="创建并编写配置文件"></a>创建并编写配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">         http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 告知 spring 创建容器时要扫描的包 --&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">&lt;!-- 配置 dbAssit 此处我们只注入了数据源，表明每条语句独立事务--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dbAssit&quot; class&#x3D;&quot;com.syx.dbassit.DBAssit&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 配置数据源 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;spring&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>



<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a><center>常用注解</center></h1><h2 id="用于创建对象的"><a href="#用于创建对象的" class="headerlink" title="用于创建对象的"></a>用于创建对象的</h2><p><code>相当于：&lt;bean&gt; id = &quot;&quot; class =&quot;&quot;&gt;</code> </p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><blockquote>
<p><strong>作用</strong>：<br>把资源让 spring 来管理。相当于在 xml 中配置一个 bean。<br><strong>属性</strong>：<br>value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。  </p>
</blockquote>
<h3 id="Controller-Service-Repository"><a href="#Controller-Service-Repository" class="headerlink" title="@Controller @Service @Repository"></a>@Controller @Service @Repository</h3><blockquote>
<p>他们三个注解都是针对一个的衍生注解，他们的作用及属性都是一模一样的。<br>他们只不过是提供了更加明确的语义化。<br>@Controller： 一般用于表现层的注解。<br>@Service： 一般用于业务层的注解。<br>@Repository： 一般用于持久层的注解。<br>细节：如果注解中有且只有一个属性要赋值时，且名称是 value， value 在赋值是可以不写。  </p>
</blockquote>
<h2 id="用于注入数据的"><a href="#用于注入数据的" class="headerlink" title="用于注入数据的"></a>用于注入数据的</h2><p><code>相当于:&lt;property name =&quot;&quot; ref = “&quot;&gt;  &lt;property name=&quot;&quot; value=&quot;&quot;&gt;</code></p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><blockquote>
<p><strong>作用</strong>：<br>自动按照类型注入。当使用注解注入属性时， set 方法可以省略。它只能注入其他 bean 类型。当有多个<br>类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到<br>就报错。  </p>
</blockquote>
<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><blockquote>
<p><strong>作用</strong>：<br>在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和<br>@Autowire 一起使用；但是给方法参数注入时，可以独立使用。<br><strong>属性</strong>：<br>value：指定 bean 的 id。  </p>
</blockquote>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><blockquote>
<p><strong>作用</strong>：<br>直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。<br><strong>属性</strong>：<br>name：指定 bean 的 id。  </p>
</blockquote>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><blockquote>
<p><strong>作用</strong>：<br>注入基本数据类型和 String 类型数据的<br><strong>属性</strong>：<br>value：用于指定值  </p>
</blockquote>
<h2 id="用于改变作用范围的："><a href="#用于改变作用范围的：" class="headerlink" title="用于改变作用范围的："></a>用于改变作用范围的：</h2><p><code>相当于 &lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;</code></p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><blockquote>
<p><strong>作用</strong>：<br>指定 bean 的作用范围。<br><strong>属性</strong>：<br>value：指定范围的值。<br><strong>取值</strong>： singleton prototype request session globalsession  </p>
</blockquote>
<h2 id="和生命周期相关的："><a href="#和生命周期相关的：" class="headerlink" title="和生命周期相关的："></a>和生命周期相关的：</h2><p><code>相当于 &lt;bena id=&quot;&quot; class=&quot;&quot; init-method=&quot;&quot; destory-method=&quot;&quot;&gt;</code></p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><blockquote>
<p><strong>作用</strong>：用于指定初始化方法。  </p>
</blockquote>
<h3 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h3><blockquote>
<p><strong>作用</strong>：用于指定销毁方法。  </p>
</blockquote>
<h1 id="新注解说明"><a href="#新注解说明" class="headerlink" title="新注解说明"></a><center>新注解说明</center></h1><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><blockquote>
<p><strong>作用</strong>：<br>用于指定当前类是一个 spring 配置类， 当创建容器时会从该类上加载注解。 获取容器时需要使用<br>AnnotationApplicationContext(有@Configuration 注解的类.class)。<br><strong>属性</strong>：<br>value:用于指定配置类的字节码  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例代码：</span><br><span class="line">&#x2F;**</span><br><span class="line">* spring 的配置类，相当于 bean.xml 文件</span><br><span class="line">*&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**注意：</span><br><span class="line">*我们已经把配置文件用类来代替了， 但是如何配置创建容器时要扫描的包呢</span><br><span class="line">*请看下一个注解。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><blockquote>
<p><strong>作用</strong>：<br>用于指定 spring 在初始化容器时要扫描的包。 作用和在 spring 的 xml 配置文件中的：<br>&lt;context:component-scan base-package=”com.itheima”/&gt;是一样的。<br><strong>属性</strong>：<br>basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。<br><strong>示例代码</strong>：<br>/<em>*<br>\</em> spring 的配置类，相当于 bean.xml 文件<br>* @Version 1.0<br>*/<br>@Configuration<br>@ComponentScan(“com.itheima”)<br>public class SpringConfiguration {<br>}<br>注意：<br>我们已经配置好了要扫描的包，但是数据源和 JdbcTemplate 对象如何从配置文件中移除呢？<br>请看下一个注解。  </p>
</blockquote>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><blockquote>
<p><strong>作用</strong>：<br>该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。<br><strong>属性</strong>：<br>name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。  </p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 连接数据库的配置类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 创建一个数据源，并存入 spring 容器中</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Bean(name&#x3D;&quot;dataSource&quot;)</span><br><span class="line">public DataSource createDataSource() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ComboPooledDataSource ds &#x3D; new ComboPooledDataSource();</span><br><span class="line">ds.setUser(&quot;root&quot;);</span><br><span class="line">ds.setPassword(&quot;1234&quot;);</span><br><span class="line">ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">ds.setJdbcUrl(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;spring_day02&quot;);</span><br><span class="line">return ds;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 创建一个 DBAssit，并且也存入 spring 容器中</span><br><span class="line">* @param dataSource</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Bean(name&#x3D;&quot;dbAssit&quot;)</span><br><span class="line">public DBAssit createDBAssit(DataSource dataSource) &#123;</span><br><span class="line">return new DBAssit(dataSource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">我们已经把数据源和 DBAssit 从配置文件中移除了，此时可以删除 bean.xml 了。</span><br><span class="line">但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？</span><br><span class="line">请看下一个注解。</span><br></pre></td></tr></table></figure>

<h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><blockquote>
<p><strong>作用</strong>：  </p>
<p>用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到<br>properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。<br><strong>属性</strong>：<br>value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath:  </p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置：</span><br><span class="line">&#x2F;**</span><br><span class="line">* 连接数据库的配置类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">private String driver;</span><br><span class="line">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">private String url;</span><br><span class="line">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">private String username;</span><br><span class="line">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">private String password;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 创建一个数据源，并存入 spring 容器中</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@Bean(name&#x3D;&quot;dataSource&quot;)</span><br><span class="line">public DataSource createDataSource() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ComboPooledDataSource ds &#x3D; new ComboPooledDataSource();</span><br><span class="line">ds.setDriverClass(driver);</span><br><span class="line">ds.setJdbcUrl(url);</span><br><span class="line">ds.setUser(username);</span><br><span class="line">ds.setPassword(password);</span><br><span class="line">return ds;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">jdbc.properties 文件：</span><br><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;pring、</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;root</span><br><span class="line">注意：</span><br><span class="line">此时我们已经有了两个配置类，但是他们还没有关系。如何建立他们的关系呢？</span><br><span class="line">请看下一个注解。</span><br></pre></td></tr></table></figure>

<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><blockquote>
<p><strong>作用</strong>：<br>用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。 当然，写上也没问<br>题。<br><strong>属性</strong>：<br>value[]：用于指定其他配置类的字节码。<br>示例代码：<br>@Configuration<br>@ComponentScan(basePackages = “com.itheima.spring”)<br>@Import({ JdbcConfig.class})<br>public class SpringConfiguration {<br>}</p>
<p>@Configuration<br>@PropertySource(“classpath:jdbc.properties”)<br>public class JdbcConfig{<br>}<br>注意：<br>我们已经把要配置的都配置好了，但是新的问题产生了，由于没有配置文件了，如何获取容器呢？<br>请看下一小节。  </p>
</blockquote>
<h3 id="通过注解获取容器"><a href="#通过注解获取容器" class="headerlink" title="通过注解获取容器"></a>通过注解获取容器</h3><blockquote>
<p>ApplicationContext ac =new AnnotationConfigApplicationContext(SpringConfiguration.class);  </p>
</blockquote>
<h1 id="Spring-整合-Junit"><a href="#Spring-整合-Junit" class="headerlink" title="Spring 整合 Junit"></a><center>Spring 整合 Junit</center></h1><h2 id="第一步：导入Junit依赖"><a href="#第一步：导入Junit依赖" class="headerlink" title="第一步：导入Junit依赖"></a>第一步：导入Junit依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第二步：使用-RunWith-注解替换原有运行器"><a href="#第二步：使用-RunWith-注解替换原有运行器" class="headerlink" title="第二步：使用@RunWith 注解替换原有运行器"></a>第二步：使用@RunWith 注解替换原有运行器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 测试类</span><br><span class="line">*&#x2F;</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三步：使用-ContextConfiguration-指定-spring-配置文件的位置"><a href="#第三步：使用-ContextConfiguration-指定-spring-配置文件的位置" class="headerlink" title="第三步：使用@ContextConfiguration 指定 spring 配置文件的位置"></a>第三步：使用@ContextConfiguration 指定 spring 配置文件的位置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 测试类</span><br><span class="line">*&#x2F;</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations&#x3D; &#123;&quot;classpath:bean.xml&quot;&#125;)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@ContextConfiguration 注解：<br>locations 属性： 用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明<br>classes 属性： 用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。  </p>
</blockquote>
<h2 id="第四步：使用-Autowired-给测试类中的变量注入数据"><a href="#第四步：使用-Autowired-给测试类中的变量注入数据" class="headerlink" title="第四步：使用@Autowired 给测试类中的变量注入数据"></a>第四步：使用@Autowired 给测试类中的变量注入数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 测试类</span><br><span class="line">*&#x2F;</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations&#x3D; &#123;&quot;classpath:bean.xml&quot;&#125;)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private IAccountService as ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMvc入门及常用注解</title>
    <url>/2020/04/06/SpringMvc%E5%85%A5%E9%97%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="三层架构和MVC"><a href="#三层架构和MVC" class="headerlink" title="三层架构和MVC "></a><center>三层架构和MVC </center></h1><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><ol>
<li>开发服务器端程序，一般都基于两种形式，一种C/S架构程序，一种B/S架构程序  </li>
<li>使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构  </li>
<li>三层架构<ol>
<li>表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型  </li>
<li>业务层：处理公司具体的业务逻辑的  </li>
<li>持久层：用来操作数据库的  </li>
</ol>
</li>
</ol>
<h2 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h2><ol>
<li>MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。</li>
<li>Model：数据模型，JavaBean的类，用来进行数据封装。</li>
<li>View：指JSP、HTML用来展示数据给用户 </li>
<li>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。  </li>
</ol>
<h2 id="SpringMVC的入门"><a href="#SpringMVC的入门" class="headerlink" title="SpringMVC的入门"></a>SpringMVC的入门</h2><h3 id="SpringMVC的概述"><a href="#SpringMVC的概述" class="headerlink" title="SpringMVC的概述"></a>SpringMVC的概述</h3><ol>
<li><p>SpringMVC的概述  </p>
<ol>
<li>是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级WEB框架。  </li>
<li>Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。  </li>
<li>使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的<br>SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2等。  </li>
</ol>
</li>
<li><p>SpringMVC在三层架构中的位置  </p>
<p>表现层框架</p>
<p><img src="/" class="lazyload" data-src="/img/SpringMvc/1.png"  alt=""></p>
</li>
<li><p>SpringMVC的优势  </p>
<blockquote>
<ol>
<li>清晰的角色划分：<br>前端控制器（DispatcherServlet）<br>请求到处理器映射（HandlerMapping）<br>处理器适配器（HandlerAdapter）<br>视图解析器（ViewResolver）<br>处理器或页面控制器（Controller）<br>验证器（ Validator）<br>命令对象（Command 请求参数绑定到的对象就叫命令对象）<br>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</li>
<li>分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。</li>
<li>由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。</li>
<li>和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。</li>
<li>可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。</li>
<li>可定制性， HandlerMapping、 ViewResolver 等能够非常简单的定制。</li>
<li>功能强大的数据验证、格式化、绑定机制。</li>
<li>利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。</li>
<li>本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</li>
<li>强大的 JSP 标签库，使 JSP 编写更容易。</li>
<li>还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配<br>置支持等等。  </li>
</ol>
</blockquote>
</li>
<li><p>SpringMVC 和 Struts2 的优略分析 </p>
<blockquote>
<p>共同点：</p>
<ul>
<li>它们都是表现层框架，都是基于 MVC 模型编写的。</li>
<li>它们的底层都离不开原始 ServletAPI。</li>
<li>它们处理请求的机制都是一个核心控制器。</li>
</ul>
<p>区别：  </p>
<ul>
<li>Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter  </li>
<li>Spring MVC 是基于方法设计的，而 Struts2 是基于类， Struts2 每次执行都会创建一个动作类。所<br>以 Spring MVC 会稍微比 Struts2 快些。</li>
<li>Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便  (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。 )  </li>
<li>Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提<br>升，尤其是 struts2 的表单标签，远没有 html 执行效率高。  </li>
</ul>
</blockquote>
<h1 id="SpringMVC-的环境搭建"><a href="#SpringMVC-的环境搭建" class="headerlink" title="SpringMVC 的环境搭建"></a><center>SpringMVC 的环境搭建</center></h1></li>
</ol>
<h2 id="一、创建WEB工程，引入开发的jar包"><a href="#一、创建WEB工程，引入开发的jar包" class="headerlink" title="一、创建WEB工程，引入开发的jar包"></a>一、创建WEB工程，引入开发的jar包</h2><p>具体坐标如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 版本锁定 --&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;spring.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、配置核心的控制器（配置DispatcherServlet）"><a href="#二、配置核心的控制器（配置DispatcherServlet）" class="headerlink" title="二、配置核心的控制器（配置DispatcherServlet）"></a>二、配置核心的控制器（配置DispatcherServlet）</h2><p>在web.xml配置文件中核心控制器DispatcherServlet  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- SpringMVC的核心控制器 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servletclass&gt;</span><br><span class="line">&lt;!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt;</span><br><span class="line">&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;!-- 配置servlet启动时加载对象 --&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、编写springmvc-xml的配置文件"><a href="#三、编写springmvc-xml的配置文件" class="headerlink" title="三、编写springmvc.xml的配置文件"></a>三、编写springmvc.xml的配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 配置spring创建容器时要扫描的包 --&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;viewResolver&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 配置spring开启注解mvc的支持--&gt;</span><br><span class="line">&lt;mvc:annotation-driven&gt;&lt;&#x2F;mvc:annotation-driven&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h2 id="四、编写index-jsp和HelloController控制器类"><a href="#四、编写index-jsp和HelloController控制器类" class="headerlink" title="四、编写index.jsp和HelloController控制器类"></a>四、编写index.jsp和HelloController控制器类</h2><p>1.index.jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;入门案例&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;$&#123; pageContext.request.contextPath &#125;&#x2F;hello&quot;&gt;入门案例&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>2.HelloController  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 接收请求</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;hello&quot;)</span><br><span class="line">public String sayHello() &#123;</span><br><span class="line">System.out.println(&quot;Hello SpringMVC!!&quot;);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、在WEB-INF目录下创建pages文件夹，编写success-jsp的成功页面"><a href="#五、在WEB-INF目录下创建pages文件夹，编写success-jsp的成功页面" class="headerlink" title="五、在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面"></a>五、在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;入门成功！！&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="六、启动Tomcat服务器，进行测试"><a href="#六、启动Tomcat服务器，进行测试" class="headerlink" title="六、启动Tomcat服务器，进行测试"></a>六、启动Tomcat服务器，进行测试</h2><h2 id="入门案例的执行过程分析"><a href="#入门案例的执行过程分析" class="headerlink" title="入门案例的执行过程分析"></a>入门案例的执行过程分析</h2><ol>
<li><p>入门案例的执行流程  </p>
<ol>
<li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件  </li>
<li>开启了注解扫描，那么HelloController对象就会被创建  </li>
<li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法  </li>
<li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件  </li>
<li>Tomcat服务器渲染页面，做出响应  </li>
</ol>
</li>
<li><p>图解  </p>
<p><img src="/" class="lazyload" data-src="/img/SpringMvc/2.bmp"  alt=""></p>
</li>
<li><p>入门案例中的组件分析  </p>
<ol>
<li><p>前端控制器（DispatcherServlet）  </p>
<blockquote>
<p>用户请求到达前端控制器，它就相当于 mvc 模式中的 c， dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet 的存在降低了组件之间的耦合性。</p>
</blockquote>
</li>
<li><p>处理器映射器（HandlerMapping）  </p>
<blockquote>
<p>HandlerMapping 负责根据用户请求找到 Handler 即处理器， SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。  </p>
</blockquote>
</li>
<li><p>处理器（Handler  )</p>
<blockquote>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。  </p>
</blockquote>
</li>
<li><p>处理器适配器（HandlAdapter  )</p>
<blockquote>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。  </p>
</blockquote>
</li>
<li><p>视图解析器（View Resolver）  </p>
<blockquote>
<p>View Resolver 负责将处理结果生成 View 视图， View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。  </p>
</blockquote>
</li>
<li><p>视图（View）  </p>
<blockquote>
<p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括： jstlView、 freemarkerView、 pdfView等。我们最常用的视图就是 jsp。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面  </p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a>RequestMapping注解</h2><ol>
<li><p>RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系</p>
</li>
<li><p>RequestMapping注解可以作用在方法和类上</p>
<ol>
<li>作用在类上：第一级的访问目录</li>
<li>作用在方法上：第二级的访问目录</li>
<li>细节：路径可以不编写 / 表示应用的根目录开始</li>
<li>细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 /</li>
</ol>
</li>
<li><p>RequestMapping的属性</p>
<ol>
<li>path 指定请求路径的url</li>
<li>value value属性和path属性是一样的</li>
<li>mthod 指定该方法的请求方式</li>
<li>params 指定限制请求参数的条件</li>
<li>headers 发送的请求中必须包含的请求头  </li>
</ol>
</li>
</ol>
<h1 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定 "></a><center>请求参数的绑定 </center></h1><h2 id="请求参数的绑定说明"><a href="#请求参数的绑定说明" class="headerlink" title="请求参数的绑定说明"></a>请求参数的绑定说明</h2><ol>
<li>绑定机制  <ol>
<li>表单提交的数据都是k=v格式的 username=haha&amp;password=123  </li>
<li>SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的  </li>
<li>要求：提交表单的name和参数的名称是相同的  </li>
</ol>
</li>
<li>支持的数据类型  <ol>
<li>基本数据类型和字符串类型  </li>
<li>实体类型（JavaBean）  </li>
<li>集合数据类型（List、map集合等）  </li>
</ol>
</li>
</ol>
<h2 id="基本数据类型和字符串类型"><a href="#基本数据类型和字符串类型" class="headerlink" title="基本数据类型和字符串类型"></a>基本数据类型和字符串类型</h2><ol>
<li>提交表单的name和参数的名称是相同的  </li>
<li>区分大小写  </li>
</ol>
<h2 id="实体类型（JavaBean）"><a href="#实体类型（JavaBean）" class="headerlink" title="实体类型（JavaBean）"></a>实体类型（JavaBean）</h2><ol>
<li><p>提交表单的name和JavaBean中的属性名称需要一致  </p>
</li>
<li><p>如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成对象.属性 </p>
<p>例如：address.name  </p>
</li>
</ol>
<h2 id="给集合属性数据封装"><a href="#给集合属性数据封装" class="headerlink" title="给集合属性数据封装"></a>给集合属性数据封装</h2><ol>
<li>JSP页面编写方式：list[0].属性 ,map[‘one’].name  </li>
</ol>
<h2 id="请求参数中文乱码的解决"><a href="#请求参数中文乱码的解决" class="headerlink" title="请求参数中文乱码的解决"></a>请求参数中文乱码的解决</h2><p>在web.xml中配置Spring提供的过滤器类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filterclass&gt;</span><br><span class="line">&lt;!-- 指定字符集 --&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">&lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><ol>
<li><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。 </p>
</li>
<li><p>如果想自定义数据类型转换，可以实现Converter的接口  </p>
<ol>
<li><p>自定义类型转换器  </p>
<blockquote>
<p>/<em>*<br>\</em> 把字符串转换成日期的转换器<br>* @author rt<br><em>/<br>public class StringToDateConverter implements Converter&lt;String, Date&gt;{<br>/**<br>\</em> 进行类型转换的方法<br>*/<br>public Date convert(String source) {<br>// 判断<br>if(source == null) {<br>throw new RuntimeException(“参数不能为空”);<br>}  </p>
<p>try {<br>DateFormat df = new SimpleDateFormat(“yyyy-MM-dd”);<br>// 解析字符串<br>Date date = df.parse(source);<br>return date;<br>} catch (Exception e) {<br>throw new RuntimeException(“类型转换错误”);<br>}<br>}<br>}  </p>
</blockquote>
</li>
<li><p>注册自定义类型转换器，在springmvc.xml配置文件中编写配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注册自定义类型转换器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;conversionService&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;converters&quot;&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;cn.syx.utils.StringToDateConverter&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 开启Spring对MVC注解的支持 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven conversion-service&#x3D;&quot;conversionService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="在控制器中使用原生的ServletAPI对象"><a href="#在控制器中使用原生的ServletAPI对象" class="headerlink" title="在控制器中使用原生的ServletAPI对象"></a>在控制器中使用原生的ServletAPI对象</h2><blockquote>
<p>只需要在控制器的方法参数定义HttpServletRequest和HttpServletResponse对象  </p>
</blockquote>
<h1 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a><center>常用的注解</center></h1><h2 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="RequestParam注解"></a>RequestParam注解</h2><ol>
<li><p>作用：把请求中的指定名称的参数传递给控制器中的形参赋值  </p>
</li>
<li><p>属性  </p>
<ol>
<li>value：请求参数中的名称  </li>
<li>required：请求参数中是否必须提供此参数，默认值是true，必须提供  </li>
</ol>
</li>
<li><p>代码如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 接收请求</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;hello&quot;)</span><br><span class="line">public String sayHello(@RequestParam(value&#x3D;&quot;username&quot;,required&#x3D;false)String name) &#123;</span><br><span class="line">System.out.println(&quot;aaaa&quot;);</span><br><span class="line">System.out.println(name);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="RequestBody注解"></a>RequestBody注解</h2><ol>
<li><p>作用：用于获取请求体的内容（注意：get方法不可以）  </p>
</li>
<li><p>属性  </p>
<p>required：是否必须有请求体，默认值是true  </p>
</li>
<li><p>代码如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;</span><br><span class="line">**</span><br><span class="line">* 接收请求</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;hello&quot;)</span><br><span class="line">public String sayHello(@RequestBody String body) &#123;</span><br><span class="line">System.out.println(&quot;aaaa&quot;);</span><br><span class="line">System.out.println(body);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="PathVariable注解"><a href="#PathVariable注解" class="headerlink" title="PathVariable注解"></a>PathVariable注解</h2><ol>
<li><p>作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符  </p>
</li>
<li><p>属性  </p>
<p>value：指定url中的占位符名称  </p>
</li>
<li><p>Restful风格的URL  </p>
<ol>
<li>请求路径一样，可以根据不同的请求方式去执行后台的不同方法  </li>
<li>restful风格的URL优点  <ol>
<li>结构清晰  </li>
<li>符合标准  </li>
<li>易于理解  </li>
<li>扩展方便  </li>
</ol>
</li>
</ol>
</li>
<li><p>代码如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;user&#x2F;hello&#x2F;1&quot;&gt;入门案例&lt;&#x2F;a&gt;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 接收请求</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;hello&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public String sayHello(@PathVariable(value&#x3D;&quot;id&quot;) String id) &#123;</span><br><span class="line">System.out.println(id);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="RequestHeader注解"><a href="#RequestHeader注解" class="headerlink" title="RequestHeader注解"></a>RequestHeader注解</h2><ol>
<li><p>作用：获取指定请求头的值  </p>
</li>
<li><p>属性  </p>
<p>value：请求头的名称  </p>
</li>
<li><p>代码如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;hello&quot;)</span><br><span class="line">public String sayHello(@RequestHeader(value&#x3D;&quot;Accept&quot;) String header) &#123;</span><br><span class="line">System.out.println(header);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="CookieValue注解"><a href="#CookieValue注解" class="headerlink" title="CookieValue注解"></a>CookieValue注解</h2><ol>
<li><p>作用：用于获取指定cookie的名称的值  </p>
</li>
<li><p>属性  </p>
<p>value：cookie的名称  </p>
</li>
<li><p>代码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;hello&quot;)</span><br><span class="line">public String sayHello(@CookieValue(value&#x3D;&quot;JSESSIONID&quot;) String cookieValue) &#123;</span><br><span class="line">System.out.println(cookieValue);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="ModelAttribute注解"></a>ModelAttribute注解</h2><ol>
<li><p>作用  </p>
<ol>
<li>出现在方法上：表示当前方法会在控制器方法执行前线执行。  </li>
<li>出现在参数上：获取指定的数据给参数赋值。  </li>
</ol>
</li>
<li><p>应用场景  </p>
<p>提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。  </p>
</li>
<li><p>具体的代码  、</p>
<ol>
<li><p>修饰的方法有返回值  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 作用在方法，先执行</span><br><span class="line">* @param name</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@ModelAttribute</span><br><span class="line">public User showUser(String name) &#123;</span><br><span class="line">System.out.println(&quot;showUser执行了...&quot;);</span><br><span class="line">&#x2F;&#x2F; 模拟从数据库中查询对象</span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setName(&quot;哈哈&quot;);</span><br><span class="line">user.setPassword(&quot;123&quot;);</span><br><span class="line">user.setMoney(100d);</span><br><span class="line">return user;</span><br><span class="line">&#125; &#x2F;</span><br><span class="line">**</span><br><span class="line">* 修改用户的方法</span><br><span class="line">* @param cookieValue</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;updateUser&quot;)</span><br><span class="line">public String updateUser(User user) &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰的方法没有返回值  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;</span><br><span class="line">**</span><br><span class="line">* 作用在方法，先执行</span><br><span class="line">* @param name</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@ModelAttribute</span><br><span class="line">public void showUser(String name,Map&lt;String, User&gt; map) &#123;</span><br><span class="line">System.out.println(&quot;showUser执行了...&quot;);</span><br><span class="line">&#x2F;&#x2F; 模拟从数据库中查询对象</span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setName(&quot;哈哈&quot;);</span><br><span class="line">user.setPassword(&quot;123&quot;);</span><br><span class="line">user.setMoney(100d);</span><br><span class="line">map.put(&quot;abc&quot;, user);</span><br><span class="line">&#125; &#x2F;</span><br><span class="line">**</span><br><span class="line">* 修改用户的方法</span><br><span class="line">* @param cookieValue</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;updateUser&quot;)</span><br><span class="line">public String updateUser(@ModelAttribute(value&#x3D;&quot;abc&quot;) User user) &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="SessionAttributes注解"></a>SessionAttributes注解</h2><ol>
<li><p>作用：用于多次执行控制器方法间的参数共享  </p>
</li>
<li><p>属性  </p>
<p>value：指定存入属性的名称  </p>
</li>
<li><p>代码如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;user&quot;)</span><br><span class="line">@SessionAttributes(value&#x3D; &#123;&quot;username&quot;,&quot;password&quot;,&quot;age&quot;&#125;,types&#x3D;</span><br><span class="line">&#123;String.class,Integer.class&#125;) &#x2F;&#x2F; 把数据存入到session域对象中</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 向session中存入值</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;save&quot;)</span><br><span class="line">public String save(Model model) &#123;</span><br><span class="line">System.out.println(&quot;向session域中保存数据&quot;);</span><br><span class="line">model.addAttribute(&quot;username&quot;, &quot;root&quot;);</span><br><span class="line">model.addAttribute(&quot;password&quot;, &quot;123&quot;);</span><br><span class="line">model.addAttribute(&quot;age&quot;, 20);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125; &#x2F;</span><br><span class="line">**</span><br><span class="line">* 从session中获取值</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;find&quot;)</span><br><span class="line">public String find(ModelMap modelMap) &#123;</span><br><span class="line">String username &#x3D; (String) modelMap.get(&quot;username&quot;);</span><br><span class="line">String password &#x3D; (String) modelMap.get(&quot;password&quot;);</span><br><span class="line">Integer age &#x3D; (Integer) modelMap.get(&quot;age&quot;);</span><br><span class="line">System.out.println(username + &quot; : &quot;+password +&quot; : &quot;+age);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;</span><br><span class="line">**</span><br><span class="line">* 清除值</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">@RequestMapping(path&#x3D;&quot;&#x2F;delete&quot;)</span><br><span class="line">public String delete(SessionStatus status) &#123;</span><br><span class="line">status.setComplete();</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务控制</title>
    <url>/2020/04/05/Spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Spring-中的事务控制"><a href="#Spring-中的事务控制" class="headerlink" title="Spring 中的事务控制"></a><center>Spring 中的事务控制</center></h1><h2 id="Spring-事务控制我们要明确的"><a href="#Spring-事务控制我们要明确的" class="headerlink" title="Spring 事务控制我们要明确的"></a>Spring 事务控制我们要明确的</h2><blockquote>
<p>第一： JavaEE 体系进行分层开发，事务处理位于业务层， Spring 提供了分层设计业务层的事务处理解决方<br>案。<br>第二： spring 框架为我们提供了一组事务控制的接口。这组接口是在spring-tx-5.0.2.RELEASE.jar 中。<br>第三： spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。 我们学习的重点是使用配置的方式实现 。</p>
</blockquote>
<h2 id="Spring-中事务控制的-API-介绍"><a href="#Spring-中事务控制的-API-介绍" class="headerlink" title="Spring 中事务控制的 API 介绍"></a>Spring 中事务控制的 API 介绍</h2><h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><blockquote>
<p>此接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法，如下图：  </p>
<p><img src="/" class="lazyload" data-src="/img/Spring/3.png"  alt=""></p>
<p>我们在开发中都是使用它的实现类，  真正管理事务的对象<br>org.springframework.jdbc.datasource.DataSourceTransactionManager 使用 Spring<br>JDBC 或 iBatis 进行持久化数据时使用<br>org.springframework.orm.hibernate5.HibernateTransactionManager 使用<br>Hibernate 版本进行持久化数据时使用</p>
</blockquote>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><blockquote>
<p>它是事务的定义信息对象，里面有如下方法：  </p>
<p><img src="/" class="lazyload" data-src="/img/Spring/4.png"  alt=""></p>
</blockquote>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p><img src="/" class="lazyload" data-src="/img/Spring/5.png"  alt=""></p>
<h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><blockquote>
<p>REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选<br>择（默认值）<br>SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）<br>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常<br>REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。<br>NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起<br>NEVER:以非事务方式运行，如果当前存在事务，抛出异常<br>NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。  </p>
</blockquote>
<h3 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h3><blockquote>
<p>默认值是-1，没有超时限制。如果有，以秒为单位进行设置。  </p>
</blockquote>
<h3 id="是否是只读事务"><a href="#是否是只读事务" class="headerlink" title="是否是只读事务"></a>是否是只读事务</h3><blockquote>
<p>建议查询时设置为只读。  </p>
</blockquote>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><blockquote>
<p>此接口提供的是事务具体的运行状态，方法介绍如下图：  </p>
<p><img src="/" class="lazyload" data-src="/img/Spring/6.png"  alt=""></p>
</blockquote>
<h1 id="基于-XML-的声明式事务控制（配置方式）"><a href="#基于-XML-的声明式事务控制（配置方式）" class="headerlink" title="基于 XML 的声明式事务控制（配置方式）  "></a><center>基于 XML 的声明式事务控制（配置方式）  </center></h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="第一步：拷贝必要的-jar-包到工程的-lib-目录"><a href="#第一步：拷贝必要的-jar-包到工程的-lib-目录" class="headerlink" title="第一步：拷贝必要的 jar 包到工程的 lib 目录"></a>第一步：拷贝必要的 jar 包到工程的 lib 目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：创建-spring-的配置文件并导入约束"><a href="#第二步：创建-spring-的配置文件并导入约束" class="headerlink" title="第二步：创建 spring 的配置文件并导入约束"></a>第二步：创建 spring 的配置文件并导入约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此处需要导入 aop 和 tx 两个名称空间</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：准备数据库表和实体类"><a href="#第三步：准备数据库表和实体类" class="headerlink" title="第三步：准备数据库表和实体类"></a>第三步：准备数据库表和实体类</h3><blockquote>
<p>创建数据库：<br>create database spring;<br>use spring;<br>创建表：<br>create table account(<br>id int primary key auto_increment,<br>name varchar(40),<br>money float<br>)character set utf8 collate utf8_general_ci;  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 账户的实体</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Account implements Serializable &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String name;</span><br><span class="line">private Float money;</span><br><span class="line">public Integer getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(Integer id) &#123;</span><br><span class="line">this.id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">public Float getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line">public void setMoney(Float money) &#123;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Account [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, money&#x3D;&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：编写业务层接口和实现类"><a href="#第四步：编写业务层接口和实现类" class="headerlink" title="第四步：编写业务层接口和实现类"></a>第四步：编写业务层接口和实现类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 账户的业务层接口</span><br><span class="line">*&#x2F;</span><br><span class="line">public interface IAccountService &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据 id 查询账户信息</span><br><span class="line">* @param id</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">Account findAccountById(Integer id);&#x2F;&#x2F;查</span><br><span class="line">&#x2F;**</span><br><span class="line">* 转账</span><br><span class="line">* @param sourceName 转出账户名称</span><br><span class="line">* @param targeName 转入账户名称</span><br><span class="line">* @param money 转账金额</span><br><span class="line">*&#x2F;</span><br><span class="line">void transfer(String sourceName,String targeName,Float money);&#x2F;&#x2F;增删改</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 账户的业务层实现类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;private IAccountDao accountDao;</span><br><span class="line">public void setAccountDao(IAccountDao accountDao) &#123;</span><br><span class="line">this.accountDao &#x3D; accountDao;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Account findAccountById(Integer id) &#123;</span><br><span class="line">return accountDao.findAccountById(id);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void transfer(String sourceName, String targeName, Float money) &#123;</span><br><span class="line">&#x2F;&#x2F;1.根据名称查询两个账户</span><br><span class="line">Account source &#x3D; accountDao.findAccountByName(sourceName);</span><br><span class="line">Account target &#x3D; accountDao.findAccountByName(targeName);</span><br><span class="line">&#x2F;&#x2F;2.修改两个账户的金额</span><br><span class="line">source.setMoney(source.getMoney()-money);&#x2F;&#x2F;转出账户减钱</span><br><span class="line">target.setMoney(target.getMoney()+money);&#x2F;&#x2F;转入账户加钱</span><br><span class="line">&#x2F;&#x2F;3.更新两个账户</span><br><span class="line">accountDao.updateAccount(source);</span><br><span class="line">int i&#x3D;1&#x2F;0;</span><br><span class="line">accountDao.updateAccount(target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五步：编写-Dao-接口和实现类"><a href="#第五步：编写-Dao-接口和实现类" class="headerlink" title="第五步：编写 Dao 接口和实现类"></a>第五步：编写 Dao 接口和实现类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 账户的持久层接口</span><br><span class="line">*&#x2F;</span><br><span class="line">public interface IAccountDao &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据 id 查询账户信息</span><br><span class="line">* @param id</span><br><span class="line">* @return</span><br><span class="line">*&#x2F;</span><br><span class="line">Account findAccountById(Integer id);</span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据名称查询账户信息</span><br><span class="line">* @return*&#x2F;</span><br><span class="line">Account findAccountByName(String name);</span><br><span class="line">&#x2F;**</span><br><span class="line">* 更新账户信息</span><br><span class="line">* @param account</span><br><span class="line">*&#x2F;</span><br><span class="line">void updateAccount(Account account);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 账户的持久层实现类</span><br><span class="line">* 此版本 dao，只需要给它的父类注入一个数据源</span><br><span class="line">*&#x2F;</span><br><span class="line">public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123;</span><br><span class="line">@Override</span><br><span class="line">public Account findAccountById(Integer id) &#123;</span><br><span class="line">List&lt;Account&gt; list &#x3D; getJdbcTemplate().query(&quot;select * from account where</span><br><span class="line">id &#x3D; ? &quot;,new AccountRowMapper(),id);</span><br><span class="line">return list.isEmpty()?null:list.get(0);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Account findAccountByName(String name) &#123;</span><br><span class="line">List&lt;Account&gt; list &#x3D; getJdbcTemplate().query(&quot;select * from account where</span><br><span class="line">name &#x3D; ? &quot;,new AccountRowMapper(),name);</span><br><span class="line">if(list.isEmpty())&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">if(list.size()&gt;1)&#123;</span><br><span class="line">throw new RuntimeException(&quot;结果集不唯一，不是只有一个账户对象&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return list.get(0);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void updateAccount(Account account) &#123;</span><br><span class="line">getJdbcTemplate().update(&quot;update account set money &#x3D; ? where id &#x3D; ?</span><br><span class="line">&quot;,account.getMoney(),account.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 账户的封装类 RowMapper 的实现类*&#x2F;</span><br><span class="line">public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">Account account &#x3D; new Account();</span><br><span class="line">account.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">account.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">account.setMoney(rs.getFloat(&quot;money&quot;));</span><br><span class="line">return account;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第六步：在配置文件中配置业务层和持久层对"><a href="#第六步：在配置文件中配置业务层和持久层对" class="headerlink" title="第六步：在配置文件中配置业务层和持久层对"></a>第六步：在配置文件中配置业务层和持久层对</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置 service --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDao&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 配置 dao --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountDao&quot; class&#x3D;&quot;com.syx.dao.impl.AccountDaoImpl&quot;&gt;</span><br><span class="line">&lt;!-- 注入 dataSource --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 配置数据源 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;spring&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="第一步：-配置事务管理器"><a href="#第一步：-配置事务管理器" class="headerlink" title="第一步： 配置事务管理器"></a>第一步： 配置事务管理器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置一个事务管理器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;!-- 注入 DataSource --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：配置事务的通知引用事务管理器"><a href="#第二步：配置事务的通知引用事务管理器" class="headerlink" title="第二步：配置事务的通知引用事务管理器"></a>第二步：配置事务的通知引用事务管理器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 事务的配置 --&gt;</span><br><span class="line">&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;</span><br><span class="line">&lt;&#x2F;tx:advice&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：配置事务的属性"><a href="#第三步：配置事务的属性" class="headerlink" title="第三步：配置事务的属性"></a>第三步：配置事务的属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--在 tx:advice 标签内部 配置事务的属性 --&gt;</span><br><span class="line">&lt;tx:attributes&gt;</span><br><span class="line">&lt;!-- 指定方法名称：是业务核心方法</span><br><span class="line">read-only：是否是只读事务。默认 false，不只读。</span><br><span class="line">isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。</span><br><span class="line">propagation：指定事务的传播行为。</span><br><span class="line">timeout：指定超时时间。默认值为： -1。永不超时。</span><br><span class="line">rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。</span><br><span class="line">没有默认值，任何异常都回滚。</span><br><span class="line">no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回</span><br><span class="line">滚。没有默认值，任何异常都回滚。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;tx:method name&#x3D;&quot;*&quot; read-only&#x3D;&quot;false&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;</span><br><span class="line">&lt;tx:method name&#x3D;&quot;find*&quot; read-only&#x3D;&quot;true&quot; propagation&#x3D;&quot;SUPPORTS&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;tx:attributes&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：配置-AOP-切入点表达式"><a href="#第四步：配置-AOP-切入点表达式" class="headerlink" title="第四步：配置 AOP 切入点表达式"></a>第四步：配置 AOP 切入点表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置 aop --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;!-- 配置切入点表达式 --&gt;</span><br><span class="line">&lt;aop:pointcut expression&#x3D;&quot;execution(* com.syx.service.impl.*.*(..))&quot;</span><br><span class="line">id&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第五步：配置切入点表达式和事务通知的对应关系"><a href="#第五步：配置切入点表达式和事务通知的对应关系" class="headerlink" title="第五步：配置切入点表达式和事务通知的对应关系"></a>第五步：配置切入点表达式和事务通知的对应关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在 aop:config 标签内部： 建立事务的通知和切入点表达式的关系 --&gt;</span><br><span class="line">&lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;pt1&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="基于注解的配置方式"><a href="#基于注解的配置方式" class="headerlink" title="基于注解的配置方式  "></a><center>基于注解的配置方式  </center></h1><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="第一步：拷贝必要的-jar-包到工程的-lib-目录-1"><a href="#第一步：拷贝必要的-jar-包到工程的-lib-目录-1" class="headerlink" title="第一步：拷贝必要的 jar 包到工程的 lib 目录"></a>第一步：拷贝必要的 jar 包到工程的 lib 目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：创建-spring-的配置文件导入约束并配置扫描的包"><a href="#第二步：创建-spring-的配置文件导入约束并配置扫描的包" class="headerlink" title="第二步：创建 spring 的配置文件导入约束并配置扫描的包"></a>第二步：创建 spring 的配置文件导入约束并配置扫描的包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.syx&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">&lt;!-- 配置 JdbcTemplate--&gt;&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- 配置 spring 提供的内置数据源 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driverClassName&quot;value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot;value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring2&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：准备数据库表和实体类-1"><a href="#第三步：准备数据库表和实体类-1" class="headerlink" title="第三步：准备数据库表和实体类"></a>第三步：准备数据库表和实体类</h3><blockquote>
<p>与前面相同</p>
</blockquote>
<h3 id="第四步：创建业务层接口和实现类并使用注解让-spring-管理"><a href="#第四步：创建业务层接口和实现类并使用注解让-spring-管理" class="headerlink" title="第四步：创建业务层接口和实现类并使用注解让 spring 管理"></a>第四步：创建业务层接口和实现类并使用注解让 spring 管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 账户的业务层实现类</span><br><span class="line">*&#x2F;</span><br><span class="line">@Service(&quot;accountService&quot;)</span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private IAccountDao accountDao;</span><br><span class="line">&#x2F;&#x2F;其余代码和基于 XML 的配置相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五步：创建-Dao-接口和实现类并使用注解让-spring-管理"><a href="#第五步：创建-Dao-接口和实现类并使用注解让-spring-管理" class="headerlink" title="第五步：创建 Dao 接口和实现类并使用注解让 spring 管理"></a>第五步：创建 Dao 接口和实现类并使用注解让 spring 管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 账户的持久层实现类</span><br><span class="line">*&#x2F;</span><br><span class="line">@Repository(&quot;accountDao&quot;)</span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private JdbcTemplate jdbcTemplate;</span><br><span class="line">&#x2F;&#x2F;其余代码和基于 XML 的配置相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置步骤-1"><a href="#配置步骤-1" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="第一步：配置事务管理器并注入数据源"><a href="#第一步：配置事务管理器并注入数据源" class="headerlink" title="第一步：配置事务管理器并注入数据源"></a>第一步：配置事务管理器并注入数据源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：在业务层使用-Transactional-注解"><a href="#第二步：在业务层使用-Transactional-注解" class="headerlink" title="第二步：在业务层使用@Transactional 注解"></a>第二步：在业务层使用@Transactional 注解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service(&quot;accountService&quot;)</span><br><span class="line">@Transactional(readOnly&#x3D;true,propagation&#x3D;Propagation.SUPPORTS)</span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private IAccountDao accountDao;</span><br><span class="line">@Override</span><br><span class="line">public Account findAccountById(Integer id) &#123;</span><br><span class="line">return accountDao.findAccountById(id);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">@Transactional(readOnly&#x3D;false,propagation&#x3D;Propagation.REQUIRED)</span><br><span class="line">public void transfer(String sourceName, String targeName, Float money) &#123;</span><br><span class="line">&#x2F;&#x2F;1.根据名称查询两个账户</span><br><span class="line">Account source &#x3D; accountDao.findAccountByName(sourceName);</span><br><span class="line">Account target &#x3D; accountDao.findAccountByName(targeName);</span><br><span class="line">&#x2F;&#x2F;2.修改两个账户的金额</span><br><span class="line">source.setMoney(source.getMoney()-money);&#x2F;&#x2F;转出账户减钱</span><br><span class="line">target.setMoney(target.getMoney()+money);&#x2F;&#x2F;转入账户加钱</span><br><span class="line">&#x2F;&#x2F;3.更新两个账户</span><br><span class="line">accountDao.updateAccount(source);</span><br><span class="line">&#x2F;&#x2F;int i&#x3D;1&#x2F;0;</span><br><span class="line">accountDao.updateAccount(target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。</span><br><span class="line">出现接口上，表示该接口的所有实现类都有事务支持。</span><br><span class="line">出现在类上，表示类中所有方法有事务支持</span><br><span class="line">出现在方法上，表示方法有事务支持。</span><br><span class="line">以上三个位置的优先级：方法&gt;类&gt;接口</span><br></pre></td></tr></table></figure>

<h3 id="第三步：在配置文件中开启-spring-对注解事务的支持"><a href="#第三步：在配置文件中开启-spring-对注解事务的支持" class="headerlink" title="第三步：在配置文件中开启 spring 对注解事务的支持"></a>第三步：在配置文件中开启 spring 对注解事务的支持</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启 spring 对注解事务的支持 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="不使用-xml-的配置方式"><a href="#不使用-xml-的配置方式" class="headerlink" title="不使用 xml 的配置方式"></a>不使用 xml 的配置方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class SpringTxConfiguration &#123;</span><br><span class="line">&#x2F;&#x2F;里面配置数据源，配置 JdbcTemplate,配置事务管理器。在之前的步骤已经写过了。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax使用</title>
    <url>/2020/03/22/ajax%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="ajax使用"><a href="#ajax使用" class="headerlink" title="ajax使用"></a><center>ajax使用</center></h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>1.概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML</p>
<p>异步和同步：客户端和服务器端相互通信的基础上</p>
<ul>
<li>客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</li>
<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。<br>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>
<li>提升用户的体验</li>
</ul>
<a id="more"></a>

<p><img src="/" class="lazyload" data-src="/img/ajax.bmp"  alt="效果图"></p>
<h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><ul>
<li><p>原生js实现：(太过于麻烦，很少有人使用)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//1.创建核心对象</span><br><span class="line">var xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest)</span><br><span class="line">&#123;// code <span class="keyword">for</span> IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">xmlhttp=new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;// code <span class="keyword">for</span> IE6, IE5</span><br><span class="line">xmlhttp=new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2. 建立连接</span><br><span class="line">/*</span><br><span class="line">参数：</span><br><span class="line">1. 请求方式：GET、POST</span><br><span class="line">* get方式，请求参数在URL后边拼接。send方法为空参</span><br><span class="line">* post方式，请求参数在send方法中定义</span><br><span class="line">2. 请求的URL：</span><br><span class="line">3. 同步或异步请求：<span class="literal">true</span>（异步）或 <span class="literal">false</span>（同步）</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajaxServlet?username=tom"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">//3.发送请求</span><br><span class="line">xmlhttp.send();</span><br><span class="line"></span><br><span class="line">//4.接受并处理来自服务器的响应结果</span><br><span class="line">//获取方式 ：xmlhttp.responseText</span><br><span class="line">//什么时候获取？当服务器响应成功后再获取</span><br><span class="line"></span><br><span class="line">//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。</span><br><span class="line">xmlhttp.onreadystatechange=<span class="keyword">function</span>()</span><br><span class="line">&#123;</span><br><span class="line">//判断readyState就绪状态是否为4，判断status响应状态码是否为200</span><br><span class="line"><span class="keyword">if</span> (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</span><br><span class="line">&#123;</span><br><span class="line">//获取服务器的响应结果</span><br><span class="line">var responseText = xmlhttp.responseText;</span><br><span class="line">alert(responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jquery实现：</p>
<blockquote>
<p>Jquery是一个JavaScript框架，使用前必须引入依赖jar包 </p>
</blockquote>
<ol>
<li><strong>$.ajax()</strong><ul>
<li>语法：$.ajax({键值对});<br>//使用$.ajax()发送异步请求</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">                url:<span class="string">"ajaxServlet"</span> , // 请求路径</span><br><span class="line">                <span class="built_in">type</span>:<span class="string">"POST"</span> , //请求方式</span><br><span class="line">                //data: <span class="string">"username=jack&amp;age=23"</span>,//请求参数</span><br><span class="line">                data:&#123;<span class="string">"username"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:23&#125;,</span><br><span class="line">                success:<span class="keyword">function</span> (data) &#123;</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;,//响应成功后的回调函数</span><br><span class="line">                error:<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                    alert(<span class="string">"出错啦..."</span>)</span><br><span class="line">                &#125;,//表示如果请求响应出现错误，会执行的回调函数</span><br><span class="line"></span><br><span class="line">                dataType:<span class="string">"text"</span>//设置接受到的响应数据的格式</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>$.get()</strong>：发送get请求<ul>
<li>语法：$.get(url, [data], [callback], [type]</li>
<li>参数：<ul>
<li>url：请求路径</li>
<li>data:请求参数</li>
<li>callback：回调函数</li>
<li>type: 响应结果类型</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">"user/findOne"</span>,&#123;&#125;,<span class="keyword">function</span> (data) &#123;</span><br><span class="line">            var str = <span class="string">"欢迎回来,"</span>+data.name;</span><br><span class="line">            $(<span class="string">"#span_name"</span>).html(str);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>$.post()</strong>：发送post请求<ul>
<li>语法：$.post(url, [data], [callback], [type])</li>
<li>参数：<ul>
<li>url：请求路径</li>
<li>data:请求参数</li>
<li>callback：回调函数</li>
<li>type: 响应结果类型</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$.post(<span class="string">"user/login"</span>,$(<span class="string">"#loginForm"</span>).serialize(),<span class="keyword">function</span> (data) &#123;</span><br><span class="line">   <span class="keyword">if</span> (data.flag)&#123;</span><br><span class="line">      location.href=<span class="string">"index.html"</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(<span class="string">"#errorMsg"</span>).html(data.errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>$(“#id”).serialize()可以把from表单的内容变为键值对形式。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习简介</title>
    <url>/2021/04/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="1-深度学习概念"><a href="#1-深度学习概念" class="headerlink" title="1.深度学习概念"></a>1.深度学习概念</h1><p><strong>深度学习</strong>(DeepLearning)是机器学习的分支，是一种以人工神经网络为架构，对数据特征进行学习的算法。</p>
<h1 id="2-机器学习和深度学习区别"><a href="#2-机器学习和深度学习区别" class="headerlink" title="2.机器学习和深度学习区别"></a>2.机器学习和深度学习区别</h1><h2 id="2-1-区别1：特征提取"><a href="#2-1-区别1：特征提取" class="headerlink" title="2.1 区别1：特征提取"></a>2.1 区别1：特征提取</h2><p><img src="/" class="lazyload" data-src="/img/DeepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/%E5%8C%BA%E5%88%AB.png"  alt=""></p>
<p>对于<strong>特征提取</strong>来说：</p>
<ul>
<li>1.机器学习需要有人工提取的过程。</li>
<li>2.深度学习没有复杂的人工特征提取的过程，特征提取的过程可以通过深度神经网络自动完成。</li>
</ul>
<h2 id="2-2-区别2：数据量"><a href="#2-2-区别2：数据量" class="headerlink" title="2.2 区别2：数据量"></a>2.2 区别2：数据量</h2><p><img src="/" class="lazyload" data-src="/img/DeepLearning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/%E6%95%B0%E6%8D%AE%E9%87%8F.png"  alt=""></p>
<p>对于<strong>数据量</strong>来说：</p>
<ul>
<li>1.深度学习需要大量的训练数据集，会有更高的效果。</li>
<li>2.度学习训练深度神经网络需要大量的算力，因为其中有更多的参数。</li>
</ul>
<h1 id="3-深度学习应用领域"><a href="#3-深度学习应用领域" class="headerlink" title="3.深度学习应用领域"></a>3.深度学习应用领域</h1><ol>
<li>图像识别<ol>
<li>物体识别</li>
<li>场景识别</li>
<li>人脸检测与跟踪</li>
<li>人脸身份认证</li>
</ol>
</li>
<li>自然语言处理<ol>
<li>机器翻译</li>
<li>文本识别</li>
<li>机器聊天对话</li>
</ol>
</li>
<li>语音识别</li>
</ol>
<h1 id="4-深度学习框架"><a href="#4-深度学习框架" class="headerlink" title="4.深度学习框架"></a>4.深度学习框架</h1><p>目前常用的学习框架有TensorFlow、Keras、 PyTorch等。</p>
<p>其中 tensorflow 和 Kears 是google出品的，使用者很多，但是其语法晦涩而且和python的语法不尽相同，对新人来说入门难度较高。</p>
<p>PyTorch的使用和python的语法相同，整个操作类似Numpy的操作，并且 PyTorch使用的是动态计算，会让代码的调试变的更加简单。</p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>深度学习简介</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringIoc（基于xml配置）</title>
    <url>/2020/04/03/SpringIoc%EF%BC%88%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-SpringIoc的概念和作用"><a href="#1-SpringIoc的概念和作用" class="headerlink" title="1.SpringIoc的概念和作用"></a>1.SpringIoc的概念和作用</h2><h3 id="1-1程序的耦合和解耦"><a href="#1-1程序的耦合和解耦" class="headerlink" title="1.1程序的耦合和解耦 "></a><CENTER>1.1程序的耦合和解耦 <CENTER></h3><h4 id="1-1-1什么是程序的耦合"><a href="#1-1-1什么是程序的耦合" class="headerlink" title="1.1.1什么是程序的耦合?"></a>1.1.1什么是程序的耦合?</h4><blockquote>
<p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调<br>用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。 耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。<br>在软件工程中， 耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是高内聚低耦合。</p>
<a id="more"></a>
<p>它有如下分类：<br>（1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另 一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。<br>（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大 量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。<br>（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。<br>（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进 行适当的动作，这种耦合被称为控制耦合。<br>（5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间 存在一个标记耦合。<br>（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。<br>（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实 现的。<br>总结：<br>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须 存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。<br>内聚与耦合内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。<br>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p>
</blockquote>
<h4 id="1-1-2解决耦合思路"><a href="#1-1-2解决耦合思路" class="headerlink" title="1.1.2解决耦合思路"></a>1.1.2解决耦合思路</h4><blockquote>
<p>当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下：<br>Class.forName(“com.mysql.jdbc.Driver”);//此处只是一个字符串<br>此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的） 。<br>同时，也产生了一个新的问题， mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 源码。<br>解决这个问题也很简单，使用配置文件配置  </p>
</blockquote>
<h4 id="1-1-3工厂模式解耦"><a href="#1-1-3工厂模式解耦" class="headerlink" title="1.1.3工厂模式解耦"></a>1.1.3工厂模式解耦</h4><blockquote>
<p>在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候， 让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。<br>那么，这个读取配置文件， 创建和获取三层对象的类就是工厂</p>
</blockquote>
<h4 id="1-1-4控制反转-Inversion-Of-Control"><a href="#1-1-4控制反转-Inversion-Of-Control" class="headerlink" title="1.1.4控制反转-Inversion Of Control"></a>1.1.4控制反转-Inversion Of Control</h4><blockquote>
<p>解耦的思路有 2 个问题：<br>1、存哪去？<br>分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。<br>到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。<br>所以我们的答案就是<br>在应用加载时，创建一个 Map，用于存放三层对象。<br>我们把这个 map 称之为容器。<br>2、还是没解释什么是工厂？<br>工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。<br>原来：<br>我们在获取对象时，都是采用 new 的方式。 是主动的。<br>现在：<br>我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。 是被动的。<br>这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。<br><strong>明确 ioc 的作用</strong>：<br>削减计算机程序的耦合(解除我们代码中的依赖关系)。  </p>
</blockquote>
<h2 id="2-使用-spring-的-IOC-解决程序耦合"><a href="#2-使用-spring-的-IOC-解决程序耦合" class="headerlink" title="2.使用 spring 的 IOC 解决程序耦合"></a><center>2.使用 spring 的 IOC 解决程序耦合</center></h2><h3 id="2-1案例的前期准备"><a href="#2-1案例的前期准备" class="headerlink" title="2.1案例的前期准备"></a>2.1案例的前期准备</h3><h4 id="2-1-1导入依赖"><a href="#2-1-1导入依赖" class="headerlink" title="2.1.1导入依赖"></a>2.1.1导入依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2创建业务层接口和实现类"><a href="#2-1-2创建业务层接口和实现类" class="headerlink" title="2.1.2创建业务层接口和实现类"></a>2.1.2创建业务层接口和实现类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 模拟保存用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void saveAccount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">    private IAccountDao accountDao &#x3D; new AccountDaoImpl();</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3创建持久层接口和实现类"><a href="#2-1-3创建持久层接口和实现类" class="headerlink" title="2.1.3创建持久层接口和实现类"></a>2.1.3创建持久层接口和实现类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 模拟保存用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void saveAccount(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;账户保存了................&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-基于-XML-的配置"><a href="#2-2-基于-XML-的配置" class="headerlink" title="2.2 基于 XML 的配置"></a>2.2 基于 XML 的配置</h3><h4 id="2-2-1在resource下创建xml配置文件，导入约束"><a href="#2-2-1在resource下创建xml配置文件，导入约束" class="headerlink" title="2.2.1在resource下创建xml配置文件，导入约束"></a>2.2.1在resource下创建xml配置文件，导入约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2让-spring-管理资源，在配置文件中配置-service-和-dao"><a href="#2-2-2让-spring-管理资源，在配置文件中配置-service-和-dao" class="headerlink" title="2.2.2让 spring 管理资源，在配置文件中配置 service 和 dao"></a>2.2.2让 spring 管理资源，在配置文件中配置 service 和 dao</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">        &lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中</span><br><span class="line">        id 属性：对象的唯一标识。</span><br><span class="line">        class 属性：指定要创建对象的全限定类名</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;!--配置Service--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.Impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--配置Dao--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountDao&quot; class&#x3D;&quot;com.syx.dao.Impl.AccountDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3测试配置是否成功"><a href="#2-2-3测试配置是否成功" class="headerlink" title="2.2.3测试配置是否成功"></a>2.2.3测试配置是否成功</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;使用ApplicationContext接口，获取spring容器</span><br><span class="line">        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;根基bean的id获取对象 </span><br><span class="line">        AccountServiceImpl accountService &#x3D; ac.getBean(&quot;accountService&quot;, AccountServiceImpl.class);</span><br><span class="line">        System.out.println(accountService);</span><br><span class="line">        AccountDaoImpl accountDao &#x3D; ac.getBean(&quot;accountDao&quot;, AccountDaoImpl.class);</span><br><span class="line">        System.out.println(accountDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Spring基于xml的Ioc细节"><a href="#3-Spring基于xml的Ioc细节" class="headerlink" title="3.Spring基于xml的Ioc细节"></a><center>3.Spring基于xml的Ioc细节</center></h2><p>spring 中工厂的类结构图  </p>
<p><img src="/" class="lazyload" data-src="/img/Spring/1.png"  alt=""></p>
<h3 id="3-1BeanFactory-和-ApplicationContext-的区别"><a href="#3-1BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="3.1BeanFactory 和 ApplicationContext 的区别"></a>3.1BeanFactory 和 ApplicationContext 的区别</h3><blockquote>
<p>BeanFactory 才是 Spring 容器中的顶层接口。<br>ApplicationContext 是它的子接口。<br>BeanFactory 和 ApplicationContext 的区别：<br>创建对象的时间点不一样。<br>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。<br>BeanFactory：什么使用什么时候创建对象。  </p>
</blockquote>
<h3 id="3-2ApplicationContext-接口的实现类"><a href="#3-2ApplicationContext-接口的实现类" class="headerlink" title="3.2ApplicationContext 接口的实现类"></a>3.2ApplicationContext 接口的实现类</h3><blockquote>
<p>ClassPathXmlApplicationContext：<br>它是从类的根路径下加载配置文件 推荐使用这种<br>FileSystemXmlApplicationContext：<br>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。<br>AnnotationConfigApplicationContext:<br>当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
</blockquote>
<h2 id="4-IOC-中-bean-标签和管理对象细节"><a href="#4-IOC-中-bean-标签和管理对象细节" class="headerlink" title="4.IOC 中 bean 标签和管理对象细节"></a><center>4.IOC 中 bean 标签和管理对象细节</center></h2><h3 id="4-1-bean标签"><a href="#4-1-bean标签" class="headerlink" title="4.1.bean标签"></a>4.1.bean标签</h3><blockquote>
<p>作用：<br>用于配置对象让 spring 来创建的。<br>默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。<br>属性：<br>id： 给对象在容器中提供一个唯一标识。用于获取对象。<br>class： 指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。<br>scope： 指定对象的作用范围。</p>
<ul>
<li>singleton :默认值，单例的.</li>
<li>prototype :多例的.</li>
<li>request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.</li>
<li>session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.</li>
<li>global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session.</li>
</ul>
<p>init-method： 指定类中的初始化方法名称。<br>destroy-method： 指定类中销毁方法名称。</p>
</blockquote>
<h3 id="4-2bean-的作用范围和生命周期"><a href="#4-2bean-的作用范围和生命周期" class="headerlink" title="4.2bean 的作用范围和生命周期"></a>4.2bean 的作用范围和生命周期</h3><blockquote>
<p>单例对象： scope=”singleton”<br>    一个应用只有一个对象的实例。它的作用范围就是整个引用。<br>    生命周期：<br>        对象出生：当应用加载，创建容器时，对象就被创建了。<br>        对象活着：只要容器在，对象一直活着。<br>        对象死亡：当应用卸载，销毁容器时，对象就被销毁了。<br>多例对象： scope=”prototype”<br>    每次访问对象时，都会重新创建对象实例。<br>    生命周期：<br>        对象出生：当使用对象时，创建新的对象实例。<br>        对象活着：只要对象在使用中，就一直活着。<br>        对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</p>
</blockquote>
<h3 id="4-3实例化-Bean-的三种方式"><a href="#4-3实例化-Bean-的三种方式" class="headerlink" title="4.3实例化 Bean 的三种方式"></a>4.3实例化 Bean 的三种方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种方式：使用默认无参构造函数</span><br><span class="line">&lt;!--在默认情况下：</span><br><span class="line">它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.impl.AccountServiceImpl&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二种方式： spring 管理静态工厂-使用静态工厂的方法创建对象</span><br><span class="line">&#x2F;**</span><br><span class="line">* 模拟一个静态工厂，创建业务层实现类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class StaticFactory &#123;</span><br><span class="line">public static IAccountService createAccountService()&#123;</span><br><span class="line">		return new AccountServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 此种方式是:</span><br><span class="line">使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器</span><br><span class="line">id 属性：指定 bean 的 id，用于从容器中获取</span><br><span class="line">class 属性：指定静态工厂的全限定类名</span><br><span class="line">factory-method 属性：指定生产对象的静态方法</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot;</span><br><span class="line">class&#x3D;&quot;com.syx.factory.StaticFactory&quot;</span><br><span class="line">factory-method&#x3D;&quot;createAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第三种方式： spring 管理实例工厂-使用实例工厂的方法创建对象</span><br><span class="line">&#x2F;**</span><br><span class="line">* 模拟一个实例工厂，创建业务层实现类</span><br><span class="line">* 此工厂创建对象，必须现有工厂实例对象，再调用方法</span><br><span class="line">*&#x2F;</span><br><span class="line">public class InstanceFactory &#123;</span><br><span class="line">public IAccountService createAccountService()&#123;</span><br><span class="line">return new AccountServiceImpl();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 此种方式是：</span><br><span class="line">先把工厂的创建交给 spring 来管理。</span><br><span class="line">然后在使用工厂的 bean 来调用里面的方法</span><br><span class="line">factory-bean 属性：用于指定实例工厂 bean 的 id。</span><br><span class="line">factory-method 属性：用于指定实例工厂中创建对象的方法。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;instancFactory&quot; class&#x3D;&quot;com.syx.factory.InstanceFactory&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot;</span><br><span class="line">factory-bean&#x3D;&quot;instancFactory&quot;</span><br><span class="line">factory-method&#x3D;&quot;createAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-4spring-的依赖注入"><a href="#4-4spring-的依赖注入" class="headerlink" title="4.4spring 的依赖注入"></a>4.4spring 的依赖注入</h3><h4 id="4-4-1-依赖注入的概念"><a href="#4-4-1-依赖注入的概念" class="headerlink" title="4.4.1.依赖注入的概念"></a>4.4.1.依赖注入的概念</h4><blockquote>
<p>依赖注入： Dependency Injection。 它是 spring 框架核心 ioc 的具体实现。<br>我们的程序在编写时， 通过控制反转， 把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。<br>ioc 解耦只是降低他们的依赖关系，但不会消除。 例如：我们的业务层仍会调用持久层的方法。<br>那这种业务层和持久层的依赖关系， 在使用 spring 之后， 就让 spring 来维护了。<br>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
</blockquote>
<h4 id="4-4-2-构造函数注入"><a href="#4-4-2-构造函数注入" class="headerlink" title="4.4.2.构造函数注入"></a>4.4.2.构造函数注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Date   birthday;</span><br><span class="line">    public AccountDaoImpl(String name,String sex,Date birthday)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(name+&quot;,&quot;+sex+&quot;，&quot;+birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用构造函数的方式，给 service 中的属性传值</span><br><span class="line">要求：</span><br><span class="line">类中需要提供一个对应参数列表的构造函数。</span><br><span class="line">涉及的标签：</span><br><span class="line">constructor-arg</span><br><span class="line">属性：</span><br><span class="line">index:指定参数在构造函数参数列表的索引位置</span><br><span class="line">type:name:指定参数在构造函数中的名称 用这个找给谁赋值</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;上面三个都是找给谁赋值，下面两个指的是赋什么值的&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">value:它能赋的值是基本数据类型和 String 类型</span><br><span class="line">ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;birthday&quot; ref&#x3D;&quot;now&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;now&quot; class&#x3D;&quot;java.util.Date&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3-set-方法注入"><a href="#4-4-3-set-方法注入" class="headerlink" title="4.4.3.set 方法注入"></a>4.4.3.set 方法注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">private String name;</span><br><span class="line">private Integer age;</span><br><span class="line">private Date birthday;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">public void setBirthday(Date birthday) &#123;</span><br><span class="line">this.birthday &#x3D; birthday;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void saveAccount() &#123;</span><br><span class="line">System.out.println(name+&quot;,&quot;+age+&quot;,&quot;+birthday);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式</span><br><span class="line">涉及的标签：</span><br><span class="line">属性：</span><br><span class="line">name：找的是类中 set 方法后面的部分</span><br><span class="line">ref：给属性赋值是其他 bean 类型的</span><br><span class="line">value：给属性赋值是基本数据类型和 string 类型的</span><br><span class="line">实际开发中，此种方式用的较多。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;test&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;21&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;birthday&quot; ref&#x3D;&quot;now&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;now&quot; class&#x3D;&quot;java.util.Date&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-4-注入集合属性"><a href="#4-4-4-注入集合属性" class="headerlink" title="4.4.4.注入集合属性"></a>4.4.4.注入集合属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    private String[] myStrs;</span><br><span class="line">    private List&lt;String&gt; myList;</span><br><span class="line">    private Set&lt;String&gt; mySet;</span><br><span class="line">    private Map&lt;String,String&gt; myMap;</span><br><span class="line">    private Properties myProps;</span><br><span class="line"></span><br><span class="line">    public void setMyStrs(String[] myStrs) &#123;</span><br><span class="line">        this.myStrs &#x3D; myStrs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyList(List&lt;String&gt; myList) &#123;</span><br><span class="line">        this.myList &#x3D; myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMySet(Set&lt;String&gt; mySet) &#123;</span><br><span class="line">        this.mySet &#x3D; mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyMap(Map&lt;String, String&gt; myMap) &#123;</span><br><span class="line">        this.myMap &#x3D; myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyProps(Properties myProps) &#123;</span><br><span class="line">        this.myProps &#x3D; myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(Arrays.toString(myStrs));</span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">        &lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中</span><br><span class="line">        id 属性：对象的唯一标识。</span><br><span class="line">        class 属性：指定要创建对象的全限定类名</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;!--配置Service--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.syx.service.Impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 注入集合数据</span><br><span class="line">    List 结构的：array,list,set</span><br><span class="line">    Map 结构的map,entry,props,prop</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--配置Dao--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountDao&quot; class&#x3D;&quot;com.syx.dao.Impl.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myStrs&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;AAA&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;CCC&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;set&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myList&quot;&gt;</span><br><span class="line">           &lt;array&gt;</span><br><span class="line">               &lt;value&gt;AAA&lt;&#x2F;value&gt;</span><br><span class="line">               &lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">               &lt;value&gt;CCC&lt;&#x2F;value&gt;</span><br><span class="line">           &lt;&#x2F;array&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;mySet&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;AAA&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;BBB&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;CCC&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myMap&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;testA&quot;&gt;aaa&lt;&#x2F;prop&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;testB&quot;&gt;bbb&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;&#x2F;props&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;myProps&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;testA&quot; value&#x3D;&quot;aaa&quot;&gt;&lt;&#x2F;entry&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;testB&quot;&gt;</span><br><span class="line">                &lt;value&gt;bbb&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
